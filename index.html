<!DOCTYPE html>
<html lang="en">
<head>
  <title>Love Game</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
  <link rel="icon" href="youricon.png">
</head>
<body>

<canvas id="mouse-canvas"></canvas>

<div class="header">
  <h1>Love Game</h1>
  <p>~ A Quest to Assess your Mental, Physical, and Emotional Health ~</p>
</div>

<div class="navbar">
  <a href="index.html">Play</a>
  <a href="about.html">About</a>
  <a href="#">Community</a>
<!-- <a href="#" class="right">Log In</a> -->
</div>
  
<div id="intro-overlay">
  <canvas id="starfield"></canvas>
  <div id="intro-text" class="cyber-text">ENTERING CYBERSPACE <span id="loading-dots"></span></div>
</div>
<!-- SECOND SCREEN: REMINDERS -->
<div id="reminder-overlay" hidden>
  <div class="reminder-box">

  <!-- REMINDERS (visible first) -->
  <div id="reminders-content">
    <h2>REMINDERS</h2>
    <ol class="reminder-list">
      <li>Be as truthful as possible (to ensure that your final result truly reflects your current health!)</li>
      <li>Play whenever you wish to reassess your wellbeing status . . .</li>
      <li>Should you land in a territory that concerns you, apply balanced Self and External love — and return later.</li>
      <li>Societal factors, including racial bias, socioeconomic barriers, and gender identity, may influence outcomes.</li>
      <li><strong>Ecstasy</strong> — The highest realm where energy and love abound.</li>
      <li><strong>Loveland</strong> — Balance exists, though some Murktivities linger.</li>
      <li><strong>Murkland</strong> — Clouded energy causes fluctuating health.</li>
      <li><strong>Darkland</strong> — A pit where murk compounds into darkness.</li>
    </ol>
  </div>

  <!-- Arrow -->
  <div id="rules-arrow" aria-label="Show rules">➜</div>

  <!-- RULES (hidden initially) -->
  <div id="rules-content" hidden>
    <h2>RULES</h2>
    <ol class="reminder-list">
      <li>Click the card presented and answer its question.</li>
      <li>If you answer in a way that shows balanced Self and External love, your character will move up.</li>
      <li>If you answer in a way that shows an imbalance of Self and External love, your character will move down.</li>
      <li>Enough balanced answers will move your character into <strong>Loveland</strong>, and eventually, <strong>Ecstasy</strong> (without narcotics!).</li>
      <li>Enough imbalanced answers will move your character into <strong>Murkland</strong>, and eventually, <strong>Darkland</strong>.</li>
    </ol>
  </div>

  <!-- BUTTON (hidden initially) -->
  <button id="start-game" hidden>FOR SURE :)</button>

</div>

</div>

<!-- CHARACTER SELECT SCREEN -->
<div id="character-overlay" class="hidden">
  <div id="character-caption" class="hidden"></div>
  <h2 class="character-title">CHOOSE YOUR CHARACTER!</h2>

  <div class="character-grid">
    <img src="1phoenix.png" class="character" data-character="phoenix">
    <img src="2kitsune.png" class="character" data-character="kitsune">
    <img src="3wata.png" class="character" data-character="mamiwata">
    <img src="4hydra.png" class="character" data-character="hydra">
    <img src="5girl.png" class="character" data-character="human">

  </div>

  <button id="confirm-character" disabled>CONFIRM</button>
</div>

<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="side-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.03 0.15" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
    <filter id="top-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.15 0.03" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
  </defs>
</svg>

 <div id="game-screen" hidden>
    <div id="card-layer">
  <div id="card" class="card">
    <img id="card-front">
    <img id="card-back">
    <div id="choice-layer" aria-hidden="true"></div>
  </div>
</div>

  <div id="board">
    <div id="ladder-wrapper">
      <img id="game-background" />
      <img id="player-character" />
      <div id="begin-text" class="begin-text"></div>
    </div>
  </div>

  <div id="card-container"></div>
</div>
  
<script>
// =============================
// DAILY PLAY LIMIT
// =============================
 /* const todayKey = new Date().toDateString();

if (localStorage.getItem("lovegame-played") === todayKey) {
  document.body.innerHTML = `
    <div class="cyber-text" style="text-align:center; margin-top:40vh;">
      Come back tomorrow, fellow traveler . . .
    </div>
  `;
  throw new Error("Daily limit reached");
}

localStorage.setItem("lovegame-played", todayKey); --- */


let beginShown = false;
// =============================
// TIMING TUNES (faster pacing)
// =============================
const NEXT_CARD_DELAY = 1000;      // was ~2000 in your code
const MOVE_TO_CARD_DELAY = 250;    // was ~450
const LAND_SWAP_DELAY = 80;        // small delay to let the new background appear under glow

// =============================
// CARD DATA (QUESTIONS + ANSWERS)
// =============================

const PHYSICAL_CARDS = [
  {
    id: 1,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q1_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a1_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c:  0,
      d: +1,
      e: +1
    },
  // original-image pixel coords (CENTER of the letter)
  backSize: { w: 1545, h: 2000 },
  centers: {
    a: { cx: 461, cy: 1288 },
    b: { cx: 461, cy: 1404 },
    c: { cx: 461, cy: 1528 },
    d: { cx: 461, cy: 1644 },
    e: { cx: 461, cy: 1775 }
  }
  },

  {
    id: 2,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q2_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a2_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c: -1,
      d: +1,
      e: +1
    },
    
    backSize: { w: 1545, h: 2000 }, 
    centers: {
    a: { cx: 503, cy: 1287 },
    b: { cx: 503, cy: 1400 },
    c: { cx: 503, cy: 1529 },
    d: { cx: 503, cy: 1639 },
    e: { cx: 503, cy: 1767 }
  }
  },
  
{
    id: 3,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q3_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a3_back.png",

    outcomes: {
      a: 0,
      b: -1,
      c: +1,
      d: +1
    }, 
  
    backSize: { w: 1545, h: 2000 }, 
    centers: {
    a: { cx: 424, cy: 1285 },
    b: { cx: 424, cy: 1398 },
    c: { cx: 424, cy: 1528 },
    d: { cx: 424, cy: 1636 },
  }
  },

{
    id: 4,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q4_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a4_back.png",

    outcomes: {
      a: +1,
      b: +1,
      c: -1,
      d: 0
    }
  },
  
  {
    id: 5,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q5_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a5_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: +1
    }
  },

  {
    id: 6,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q6_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a6_back.png",

    outcomes: {
      a: +1,
      b: 0,
      c: -1,
      d: +1
    }
  },

  {
    id: 7,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q7_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a7_back.png",

    outcomes: {
      a: 0,
      b: +1,
      c: -1,
      d: -1
    }
  },

  {
    id: 8,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q8_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a8_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: -1
    }
  }
  // add up to 8
];

// -----------------------------
// MURKLAND CARDS (make your own)
// -----------------------------
const MURK_CARDS = [
  {
    id: 101,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q1_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a1_back.png",
    outcomes: { 
      a:-1, b:0, c:+1
    }
  },
  
{
    id: 102,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q2_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a2_back.png",
    outcomes: { 
      a:+1, b:0, c:+1, d:-1, e:-1
    }
  },

{
    id: 103,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q3_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a3_back.png",
    outcomes: { 
      a:-1, b:-1, c:+1, d:0, e:+1
    }
  },

  {
    id: 104,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q4_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a4_back.png",
    outcomes: { 
      a:+1, b:+1, c:+1, d:-1
    }
  },

    {
    id: 105,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q5_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a5_back.png",
    outcomes: { 
      a:-1, b:0, c:0, d:+1
    }
  },

  {
    id: 106,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q6_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a6_back.png",
    outcomes: { 
      a:+1, b:+1, c:0, d:-1
    }
  },

  {
    id: 107,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q7_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a7_back.png",
    outcomes: { 
      a:0, b:+1, c:-1, d:+1, e:-1
    }
  },
  
{
    id: 108,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q8_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a8_back.png",
    outcomes: { 
      a:+1, b:0, c:-1, d:+1
    }
  },
  
  // add more...
];

// -----------------------------
// LOVELAND CARDS (MENTAL)
// -----------------------------
const MENTAL_CARDS = [
  {
  id: 201,
  questionFront: "mental_q1_front.png",
  questionBack:  "mental_q1_back.png",
  answerFront:   "mental_a1_front.png",
  answerBack:    "mental_a1_back.png",
  outcomes: { a:-1, b:+1, c:0, d:-1 },
},
  
  {
    id: 202,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q2_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a2_back.png",
    outcomes: { a:-1, b:0, c:+1, d:-1 }
  },

  {
    id: 203,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q3_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a3_back.png",
    outcomes: { a:0, b:+1, c:0, d:-1 }
  },

  {
    id: 204,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q4_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a4_back.png",
    outcomes: { a:-1, b:+1, c:0, d:-1 }
  },

  {
    id: 205,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q5_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a5_back.png",
    outcomes: { a:-1, b:-1, c:0, d:+1, e:-1}
  },

  {
    id: 206,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q6_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a6_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:+1, e:0}
  },

  {
    id: 207,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q7_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a7_back.png",
    outcomes: { a:+1, b:0, c:+1, d:-1}
  },

  {
    id: 208,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q8_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a8_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:0, e:0}
  },


  // add more...
];

// -----------------------------
// ECSTASY BONUS CARD (SPECIAL)
// -----------------------------
const ECSTASY_CARD = {
  id: 301,
  questionFront: "ecstasy_q_front.png",
  questionBack:  "ecstasy_q_back.png",
  answerFront:   "ecstasy_a_front.png",
  answerBack:    "ecstasy_a_back.png",
  outcomes: { a: 0, b: -1, c: +1, d: +1 } // edit letters/outcomes to match your design
};

  
function getDeckForPhase() {
  if (questionPhase === "physical") return PHYSICAL_CARDS;
  if (questionPhase === "emotional") return MURK_CARDS;
  if (questionPhase === "mental") return MENTAL_CARDS;
  return PHYSICAL_CARDS;
}


  
function getActiveDeck() {
  // Murkland screen uses Murk-only
  if (GameState.land === "murkland") return MURK_CARDS;

  // Darkland screen can still ask emotional (Murk) questions,
  // BUT we do NOT show Murkland visuals yet.
  if (GameState.land === "darkland") return [...PHYSICAL_CARDS, ...MURK_CARDS];

  return PHYSICAL_CARDS; // fallback
}

function closeAnswerAndContinue() {
  const layer = document.getElementById("card-layer");
  if (!layer || layer.style.display === "none") return;

  layer.classList.add("fade-out");

  setTimeout(() => {
    layer.classList.remove("fade-out");
    layer.style.display = "none";

    const delta = Number(layer.dataset.delta || 0);
    const answeredCardId = Number(layer.dataset.cardId || 0);

    currentCard = null;
    cardMode = "question";
    cardSide = "front";

    // ECSTASY special handling (keep yours)
    if (typeof ECSTASY_CARD !== "undefined" && answeredCardId === ECSTASY_CARD.id) {
      if (delta > 0) {
        transitionToEcstasy();
        setTimeout(() => showJourneyEnd("ecstasy"), 2000);
      } else {
        GameState.land = "loveland";
        setTimeout(() => showJourneyEnd("loveland"), 800);
      }
      return;
    }

    // ✅ COUNT THIS ANSWER FIRST (prevents “8 answers” drifting during land transitions)
    answeredInThisDeck++;

    // ✅ Move first; if a land transition happens, it will call goNextAfterAnswer() itself
    const transitioned = moveCharacter(delta, goNextAfterAnswer);

    // Normal movement (no land transition): continue as usual
    if (!transitioned) {
      setTimeout(goNextAfterAnswer, NEXT_CARD_DELAY);
    }
  }, 220);
}


// -----------------------------
// ACTIVE DECK + TRANSITION FLAG
// -----------------------------
let activeDeck = PHYSICAL_CARDS;
let murkTransitionDone = false;

  
/* --- UNIVERSAL MOUSE STREAK SETUP --- */
const mCanvas = document.getElementById("mouse-canvas");
const mCtx = mCanvas.getContext("2d");
let mPoints = [];
const TRAIL_LIFESPAN = 12; // Shortened slightly to reduce lag

function resizeCanvases() {
  mCanvas.width = canvas.width = window.innerWidth;
  mCanvas.height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvases);

window.addEventListener("mousemove", (e) => {
  mPoints.push({ x: e.clientX, y: e.clientY, age: 0 });
});

/* --- INTRO STARFIELD SETUP --- */
const starColors = [[255, 255, 255], [200, 220, 255], [220, 200, 255], [255, 230, 180], [180, 255, 240]];
const overlay = document.getElementById("intro-overlay");
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");

let stars = [];
let shootingStars = []; 
let fireEmbers = [];    
let running = true;

/* Initialize Stars */
function createStars(count = 120) { // Slightly fewer stars for better performance
  stars = [];
  for (let i = 0; i < count; i++) {
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    stars.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: Math.random() * 1.4 + 0.3,
      speed: Math.random() * 0.12 + 0.05,
      color
    });
  }
}
createStars();

/* --- THE OPTIMIZED MERGED LOOP --- */
function animate() {
  // Clear both canvases
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  if (running) ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Draw Mouse Streak First (Optimization: Only one shadow call)
  if (mPoints.length > 1) {
    mCtx.shadowBlur = 8; // Lower value = faster performance
    mCtx.shadowColor = "#f5ff3a";
    mCtx.lineCap = "round";
    mCtx.lineJoin = "round";

    for (let i = 1; i < mPoints.length; i++) {
      const p1 = mPoints[i - 1];
      const p2 = mPoints[i];
      const opacity = 1 - (p1.age / TRAIL_LIFESPAN);
      
      mCtx.strokeStyle = `rgba(245, 255, 58, ${opacity})`; 
      mCtx.lineWidth = opacity * 5;
      
      mCtx.beginPath();
      mCtx.moveTo(p1.x, p1.y);
      mCtx.lineTo(p2.x, p2.y);
      mCtx.stroke();
      p1.age++;
    }
    mCtx.shadowBlur = 0; // Turn it off immediately for other elements
  }
  mPoints = mPoints.filter(p => p.age < TRAIL_LIFESPAN);

  // 2. Draw Intro Elements Only If Running
  if (running) {
    /* Background Stars */
    stars.forEach(star => {
      star.y += star.speed;
      if (star.y > canvas.height) star.y = 0;
      ctx.fillStyle = `rgba(${star.color[0]}, ${star.color[1]}, ${star.color[2]}, 0.8)`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    });

    /* Background Shooting Stars (White) */
    shootingStars.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) shootingStars.splice(i, 1);
    });

    /* Border Embers (Orange) */
    fireEmbers.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = "#ff8c00";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) fireEmbers.splice(i, 1);
    });

    /* Spawn Logic */
    if (Math.random() > 0.85) spawnEmbers();
  }

  requestAnimationFrame(animate);
}

function spawnEmbers() {
  const side = Math.floor(Math.random() * 4);
  let ex, ey, evx, evy;
  if (side === 0) { ex = Math.random()*canvas.width; ey = 0; evx = (Math.random()-0.5)*2; evy = Math.random()*4; } 
  else if (side === 1) { ex = Math.random()*canvas.width; ey = canvas.height; evx = (Math.random()-0.5)*2; evy = -Math.random()*4; } 
  else if (side === 2) { ex = 0; ey = Math.random()*canvas.height; evx = Math.random()*4; evy = (Math.random()-0.5)*2; } 
  else { ex = canvas.width; ey = Math.random()*canvas.height; evx = -Math.random()*4; evy = (Math.random()-0.5)*2; }
  fireEmbers.push({ x: ex, y: ey, vx: evx, vy: evy, life: 0 });
}

// Shooting star interval logic
function createShootingStar() {
  const c = starColors[Math.floor(Math.random() * starColors.length)];
  shootingStars.push({
    x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.5,
    vx: Math.random() * 7 + 5, vy: Math.random() * 3 + 2,
    life: 0, color: `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`
  });
}
const shootingInterval = setInterval(() => { if (Math.random() > 0.4) createShootingStar(); }, 300);

/* End Intro Logic */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
    enableReminderScreen(); // ✅ THIS is correct
  }, 600);
}

const timeout = setTimeout(endIntro, 3500);
/* --- Improved Skip Logic --- */

// 1. Click to Skip
overlay.addEventListener("click", () => {
  clearTimeout(timeout);
  endIntro();
}, { once: true });

// 2. Keypress to Skip (Now targeting the whole window)
window.addEventListener("keydown", (e) => {
  // This ensures the intro ends regardless of which key is pressed
  clearTimeout(timeout);
  endIntro();
}, { once: true });

resizeCanvases();
animate();
  
const dotsElement = document.getElementById('loading-dots');
let dotCount = 0;

const dotInterval = setInterval(() => {
  dotCount = (dotCount + 1) % 4; 
  // Adding a space after the dot inside the repeat function
  if(dotsElement) dotsElement.textContent = ". ".repeat(dotCount);
}, 400);

/* Update your endIntro function to stop the dots too */
/* =============================
   REMINDERS → RULES → START FLOW
============================= */

function enableReminderScreen() {
  const reminderOverlay = document.getElementById("reminder-overlay");
  const reminders = document.getElementById("reminders-content");
  const rules = document.getElementById("rules-content");
  const arrow = document.getElementById("rules-arrow");
  const startBtn = document.getElementById("start-game");

  if (!reminderOverlay || !reminders || !rules || !arrow || !startBtn) return;

  // Show reminders
  reminderOverlay.hidden = false;
  reminderOverlay.style.opacity = "0";
  requestAnimationFrame(() => {
    reminderOverlay.style.transition = "opacity 0.4s ease";
    reminderOverlay.style.opacity = "1";
  });

  // ------------------------
  // STEP 1: Click or key on reminders → show rules
  function showRules() {
    reminders.style.display = "none";
    rules.hidden = false;
    startBtn.hidden = false;
    arrow.style.display = "none";

    // Remove listeners for showing rules
    reminderOverlay.removeEventListener("click", showRules);
    window.removeEventListener("keydown", showRules);

    // Enable closing the rules screen
    enableRulesClose();
  }

  reminderOverlay.addEventListener("click", showRules);
  window.addEventListener("keydown", showRules);

  // Keep arrow clickable as alternative
  arrow.addEventListener("click", (e) => {
    e.stopPropagation();
    showRules();
  });
}

/* ------------------------
   STEP 2: Close overlay from rules
------------------------ */
function closeRules() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  overlay.style.transition = "opacity 0.5s ease";
  overlay.style.opacity = "0";

  // Remove listeners immediately to prevent double triggers
  window.removeEventListener("keydown", closeRules);
  overlay.removeEventListener("click", closeRules);

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove(); showCharacterSelect();
  }, 500);
}

function enableRulesClose() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  // Click anywhere OR any key closes the rules overlay
  overlay.addEventListener("click", closeRules);
  window.addEventListener("keydown", closeRules);

  // Also allow button to close
  document.getElementById("start-game")?.addEventListener("click", closeRules);
}

/* ------------------------
   STEP 3: Call this after intro ends
------------------------ */

/* =============================
   CHARACTER SELECT LOGIC
============================= */
/* =============================
   CHARACTER SELECT LOGIC
============================= */

let selectedCharacter = null;

  // =============================
// LOVE GAME STATE
// =============================
const GameState = {
  land: "darkland",
  category: "physical",
  rungIndex: 0,
  questionIndex: 0,
  correctCount: 0
};

// Each land has ALL letters (not just murk / love)
const LADDERS = {
  darkland: 8,   // D n A L K R A D
  murkland: 8,   // m u r k l a n d
  loveland: 8    // l o v e l a n d
};


function showCharacterSelect() {
  const overlay = document.getElementById("character-overlay");

  // force initial state
  overlay.classList.remove("fade-out");
  overlay.classList.add("visible");
}


const characters = document.querySelectorAll(".character");

characters.forEach(char => {
  char.addEventListener("click", () => {
    const overlay = document.getElementById("character-overlay");

    // Clear previous state
    characters.forEach(c => c.classList.remove("selected", "dimmed"));

    // Select current
    char.classList.add("selected");
    selectedCharacter = char.dataset.character;
    confirmBtn.disabled = false;

    // Dim others
    characters.forEach(c => {
      if (c !== char) c.classList.add("dimmed");
    });

    // Soft fade of screen
    overlay.classList.add("selection-made");
  });
});

// ✅ CONFIRM BUTTON — THIS WAS MISSING
const confirmBtn = document.getElementById("confirm-character");

confirmBtn.addEventListener("click", () => {
  if (!selectedCharacter) return;

  const overlay = document.getElementById("character-overlay");

  overlay.classList.remove("visible");
  overlay.classList.add("fade-out");

  setTimeout(() => {
    overlay.remove();
    startLoveGame();
  }, 800);
});


  // =============================
// CHARACTER MOVEMENT
// =============================
function positionCharacter() {
  const char   = document.getElementById("player-character");
  const img    = document.getElementById("game-background");
  const screen = document.getElementById("game-screen");

  const coords = RUNG_COORDS[GameState.land]; // ✅ land-aware
  const rung = RUNG_COORDS[GameState.land][GameState.rungIndex];

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  char.style.left = `${x}px`;
  char.style.top  = `${y}px`;

  const targetTop = char.offsetTop - screen.clientHeight * 0.65;
  screen.scrollTo({ top: Math.max(0, targetTop), behavior: "smooth" });
}

function bigGlowTransition(doDuringGlow, doAfterGlow = null) {
  const glow = document.createElement("div");
  glow.style.position = "fixed";
  glow.style.inset = "0";
  glow.style.zIndex = "9999999";
  glow.style.pointerEvents = "none";

  // ✅ Bigger glow: larger radius + stronger spread
  glow.style.background = `
    radial-gradient(circle at center,
      rgba(245,255,58,0.95) 0%,
      rgba(245,255,58,0.55) 25%,
      rgba(245,255,58,0.25) 50%,
      rgba(0,0,0,0) 78%
    )
  `;
  glow.style.opacity = "0";
  glow.style.transition = "opacity 0.45s ease";
  glow.style.filter = "blur(1px)"; // subtle “wrap” feel

  document.body.appendChild(glow);

  // fade IN
  requestAnimationFrame(() => {
    glow.style.opacity = "1";
  });

  // run the work while glow is fully visible
  setTimeout(() => {
    try { doDuringGlow?.(); } catch (e) { console.error(e); }

    // fade OUT after the new screen is in place
    setTimeout(() => {
      glow.style.transition = "opacity 0.65s ease";
      glow.style.opacity = "0";
      setTimeout(() => {
        glow.remove();
        doAfterGlow?.();
      }, 700);
    }, 350);
  }, 250);
}

  
function moveCharacter(delta, afterTransition = null) {

  const img = document.getElementById("game-background");

  const continueWithNextCard = () => {
    positionCharacter();
    setTimeout(() => {
      advanceCard();
    }, 450);
  };

/* =====================
   DARKLAND → MURKLAND
   (top rung, correct/up answer)
===================== */
if (
  GameState.land === "darkland" &&
  GameState.rungIndex === (LADDERS.darkland - 1) &&
  delta > 0
) {
  GameState.land = "murkland";
  GameState.rungIndex = 0;

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
      return;
    }

    img.onload = () => {
      img.onload = null; // ✅ IMPORTANT: prevent old onload from firing later
      positionCharacter();
      setTimeout(() => afterTransition?.(), 0);
    };

    img.src = "murkland_screen.png";
  });

  return true;
}

  /* =====================
     MURKLAND → DARKLAND
  ===================== */
  if (GameState.land === "murkland" && GameState.rungIndex === 0 && delta < 0) {
  GameState.land = "darkland";
  GameState.rungIndex = LADDERS.darkland - 1;
  murkTransitionDone = false; // ✅ ADD THIS
  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) return;

    img.onload = () => {
      positionCharacter();
      setTimeout(() => afterTransition?.(), 0);
    };

    img.src = "darkland_screen.png";
  });

  return true;
}

/* =====================
   MURKLAND → LOVELAND
   (top rung, correct/up answer)
===================== */
if (
  GameState.land === "murkland" &&
  GameState.rungIndex === (LADDERS.murkland - 1) &&
  delta > 0
) {
  GameState.land = "loveland";
  GameState.rungIndex = 0;

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) {
      positionCharacter();
      setTimeout(() => afterTransition?.(), 0);
      return;
    }

    img.onload = () => {
      img.onload = null;
      positionCharacter();
      setTimeout(() => afterTransition?.(), 0);
    };

    img.src = "loveland_screen.png";
  });

  return true;
}

  
 /* =====================
   LOVELAND → MURKLAND (visual drop only; KEEP current deck)
===================== */
if (GameState.land === "loveland" && GameState.rungIndex === 0 && delta < 0) {
  GameState.land = "murkland";
  GameState.rungIndex = LADDERS.murkland - 1;

  // ✅ DO NOT change questionPhase / activeDeck here.

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
      return;
    }

    img.onload = () => {
      positionCharacter();
      setTimeout(() => afterTransition?.(), 0);
    };

    img.src = "murkland_screen.png";
  });

  return true;
}



  /* =====================
     NORMAL MOVEMENT
  ===================== */
  const max = LADDERS[GameState.land] - 1;
  GameState.rungIndex = Math.max(0, Math.min(max, GameState.rungIndex + delta));
  positionCharacter();
  return false;
}
  




const subtitles = {
  phoenix: "The Fiery Phoenix . . .",
  kitsune: "The Cunning Kitsune . . .",
  mamiwata: "The Alluring Mami Wata . . .",
  hydra: "The Immortal Hydra . . .",
  human: "The Ruthless Human . . ."
};

const characterImages = {
  phoenix: "1phoenix.png",
  kitsune: "2kitsune.png",
  mamiwata: "3wata.png",
  hydra: "4hydra.png",
  human: "5girl.png"
};

const caption = document.getElementById("character-caption");

// Typewriter function
let typingInterval = null;
function typeWriter(element, text, speed = 50) {
  if (typingInterval) {
    clearInterval(typingInterval);
    typingInterval = null;
  }

  element.textContent = "";
  let i = 0;

  typingInterval = setInterval(() => {
    element.textContent += text.charAt(i);
    i++;

    if (i >= text.length) {
      clearInterval(typingInterval);
      typingInterval = null;
    }
  }, speed);
}


// Character click logic
document.querySelectorAll(".character").forEach(char => {
  char.addEventListener("click", () => {
    const key = char.dataset.character;
    if (!subtitles[key]) return;

    caption.classList.add("visible");
    typeWriter(caption, subtitles[key], 50);
  });
});
 
// =============================
// CARD ENGINE
// =============================

let currentCard = null;
let cardSide = "front";
let cardIndex = 0;
let murkLastSeenIndex = -1; // -1 means none seen yet
let questionPhase = "physical"; // physical → emotional → mental
let lovelandUnlocked = false;
let mentalLastSeenIndex = -1;
const QUESTIONS_PER_DECK = 8;
let answeredInThisDeck = 0;
let renderToken = 0;

async function setCardImages({ frontSrc, backSrc, mode, cardData }) {
  const myToken = ++renderToken;

  const layer = document.getElementById("card-layer");
  const front = document.getElementById("card-front");
  const back  = document.getElementById("card-back");
  const cardEl = document.getElementById("card");

  // Hide layer during swap to prevent flash
  layer.style.visibility = "hidden";

  // Cancel old handlers
  front.onload = null;
  back.onload = null;

  // Reset flip so we know which side is meant to be shown
  cardEl.classList.remove("flipped");

  // Swap sources
  front.src = frontSrc;
  back.src  = backSrc;

  // Wait for decode (prevents “one-frame wrong image”)
  try {
    await Promise.all([
      front.decode?.() ?? Promise.resolve(),
      back.decode?.()  ?? Promise.resolve()
    ]);
  } catch {
    // decode can fail on some browsers for cross-origin/cached oddities; safe to continue
  }

  // If another card started rendering, abort
  if (myToken !== renderToken) return;

  // Show layer ONLY after images are ready
  layer.style.visibility = "visible";

  // If we're showing question back, render hotspots once the back is ready and visible
  if (mode === "question" && cardSide === "back" && cardData) {
    requestAnimationFrame(() => {
      if (myToken === renderToken && currentCard === cardData && cardMode === "question" && cardSide === "back") {
        renderChoiceHotspots(cardData);
      }
    });
  }
}


function showQuestionCard(cardData) {
  if (!cardData) return;

  // Phase detection (keep this — you NEED it)
  if (cardData.id >= 1 && cardData.id < 100) questionPhase = "physical";
  else if (cardData.id >= 100 && cardData.id < 200) questionPhase = "emotional";
  else if (cardData.id >= 200 && cardData.id < 300) questionPhase = "mental";
  else if (cardData.id >= 300) questionPhase = "ecstasy";

  currentCard = cardData;

  // Track progress indexes (keep yours)
  const mIdx = MURK_CARDS.findIndex(c => c.id === cardData.id);
  if (mIdx !== -1) murkLastSeenIndex = mIdx;

  const tIdx = MENTAL_CARDS.findIndex(c => c.id === cardData.id);
  if (tIdx !== -1) mentalLastSeenIndex = tIdx;

  cardSide = "front";
  cardMode = "question";

  clearChoiceHotspots();

  const layer = document.getElementById("card-layer");
  layer.style.display = "flex";

  // load + decode before showing (prevents flash/jumble)
  setCardImages({
    frontSrc: cardData.questionFront,
    backSrc:  cardData.questionBack,
    mode: "question",
    cardData
  });

  scrollToCards();
}


function flashHotspot(letter) {
  const choiceLayer = document.getElementById("choice-layer");
  if (!choiceLayer) return;

  const el = choiceLayer.querySelector(`.choice-hotspot[data-letter="${letter}"]`);
  if (!el) return;

  el.classList.add("flash");
  setTimeout(() => el.classList.remove("flash"), 180);
}


  
function selectHotspot(letter) {
  const choiceLayer = document.getElementById("choice-layer");
  if (!choiceLayer) return;

  // clear previous selection
  choiceLayer.querySelectorAll(".choice-hotspot.selected")
    .forEach(el => el.classList.remove("selected"));

  const el = choiceLayer.querySelector(`.choice-hotspot[data-letter="${letter}"]`);
  if (!el) return;
  el.classList.add("selected");
}

function clearChoiceHotspots() {
  const choiceLayer = document.getElementById("choice-layer");
  if (!choiceLayer) return;
  choiceLayer.innerHTML = "";
  choiceLayer.style.pointerEvents = "none";
}

function getContainedImageRect(imgEl, refSize) {
  // host box (the on-screen img element inside the card)
  const host = imgEl.getBoundingClientRect();

  // ✅ Use your measured design size when provided
  const refW = refSize?.w || imgEl.naturalWidth || host.width;
  const refH = refSize?.h || imgEl.naturalHeight || host.height;

  const scale = Math.min(host.width / refW, host.height / refH);

  const drawW = refW * scale;
  const drawH = refH * scale;

  const offsetX = (host.width - drawW) / 2;
  const offsetY = (host.height - drawH) / 2;

  return {
    left: offsetX,
    top: offsetY,
    width: drawW,
    height: drawH,
    scaleX: scale,
    scaleY: scale
  };
}


  
const LETTER_BOX = { w: 100, h: 100 }; // same for all A–E

function renderChoiceHotspots(cardData) {
  clearChoiceHotspots();

  if (!cardData || cardMode !== "question" || cardSide !== "back") return;
  if (!cardData.outcomes) return;

  const choiceLayer = document.getElementById("choice-layer");
  const backImg = document.getElementById("card-back");
  if (!choiceLayer || !backImg) return;

  // Wait for the back image to be loaded
  if (!backImg.complete || !backImg.naturalWidth) {
    backImg.addEventListener(
      "load",
      () => {
        // Only render if we're STILL on this card and still on the back
        if (currentCard === cardData && cardMode === "question" && cardSide === "back") {
          renderChoiceHotspots(cardData);
        }
      },
      { once: true }
    );
    return;
  }

  const fit = getContainedImageRect(backImg, cardData.backSize);
  choiceLayer.style.pointerEvents = "auto";

  // -------- Option A: "centers" (A–E centers + fixed box)
  // -------- Option A: "centers" (A–E centers + fixed box)
if (cardData.centers) {
  const boxW = (cardData.letterBox?.w ?? LETTER_BOX.w);
  const boxH = (cardData.letterBox?.h ?? LETTER_BOX.h);

  Object.entries(cardData.centers).forEach(([letter, p]) => {
    if (!(letter in cardData.outcomes)) return;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "choice-hotspot letter";
    btn.dataset.letter = letter;
    btn.textContent = "";
    btn.setAttribute("aria-label", `Answer ${letter.toUpperCase()}`);

    // ✅ left/top are CENTER coords again
    btn.style.left = `${fit.left + p.cx * fit.scaleX}px`;
    btn.style.top  = `${fit.top  + p.cy * fit.scaleY}px`;
    btn.style.width  = `${boxW * fit.scaleX}px`;
    btn.style.height = `${boxH * fit.scaleY}px`;

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      selectHotspot(letter);
      flashHotspot(letter);
      setTimeout(() => resolveAnswer(letter), 100);
    });

    choiceLayer.appendChild(btn);
  });

  return;
}



  // -------- Option B: "zones" (rectangles)
// -------- Option B: "zones" (rectangles)
if (cardData.zones) {
  Object.entries(cardData.zones).forEach(([letter, z]) => {
    if (!(letter in cardData.outcomes)) return;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "choice-hotspot letter";
    btn.dataset.letter = letter;
    btn.textContent = "";
    btn.setAttribute("aria-label", `Answer ${letter.toUpperCase()}`);

    // ✅ convert TOP-LEFT zone to CENTER coords (because CSS is centered)
    const cx = z.x + z.w / 2;
    const cy = z.y + z.h / 2;

    btn.style.left   = `${fit.left + cx * fit.scaleX}px`;
    btn.style.top    = `${fit.top  + cy * fit.scaleY}px`;
    btn.style.width  = `${z.w * fit.scaleX}px`;
    btn.style.height = `${z.h * fit.scaleY}px`;

    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      selectHotspot(letter);
      flashHotspot(letter);
      setTimeout(() => resolveAnswer(letter), 100);
    });

    choiceLayer.appendChild(btn);
  });

  return;
}


  // If neither exists, nothing to draw
}



window.addEventListener("keydown", (e) => {
  if (!currentCard) return;

  const key = e.key.toLowerCase();

  // ANSWER MODE: any key flips/advances
  if (cardMode === "answer") {
    if (cardSide === "front") {
      cardEl.classList.add("flipped");
      cardSide = "back";
      return;
    }
    if (cardSide === "back") {
      closeAnswerAndContinue();
      return;
    }
  }

  // QUESTION MODE:
  if (cardMode === "question") {
    // Any key flips FRONT -> BACK
    if (cardSide === "front") {
      cardEl.classList.add("flipped");
      cardSide = "back";

      // show hotspots now that back is visible
      requestAnimationFrame(() => renderChoiceHotspots(currentCard));
      return;
    }

    // BACK: only A–E answers. Other keys do nothing.
    if (cardSide === "back") {
      if (currentCard.outcomes && (key in currentCard.outcomes)) {
        selectHotspot(key);
flashHotspot(key);
setTimeout(() => resolveAnswer(key), 140);
      }
      return;
    }
  }
});



function resolveAnswer(letter) {
  const delta = currentCard.outcomes[letter];
  showAnswerCard(currentCard, delta);
}

let cardMode = "question"; // "question" | "answer"

const cardEl = document.getElementById("card");
const layer  = document.getElementById("card-layer");

cardEl.addEventListener("click", () => {
  if (!currentCard) return;

  // QUESTION: click flips front -> back only
  // QUESTION: click flips front -> back only
if (cardMode === "question") {
  if (cardSide === "front") {
    cardEl.classList.add("flipped");
    cardSide = "back";

    // ✅ IMPORTANT: enable + build hotspots on click flip too
    requestAnimationFrame(() => renderChoiceHotspots(currentCard));
  }
  return;
}

  // ANSWER: click #1 flips front -> back
  if (cardMode === "answer" && cardSide === "front") {
    cardEl.classList.add("flipped");
    cardSide = "back";
    return;
  }

  // ANSWER: click #2 fades + closes + moves
 // ANSWER: click #2 closes + moves + advances (single source of truth)
if (cardMode === "answer" && cardSide === "back") {
  closeAnswerAndContinue();
  return;
}
}); // ✅ closes cardEl.addEventListener("click", ...)

  
function scrollToCards() {
  const screen = document.getElementById("game-screen");
  if (!screen) return;

  // make sure the GAME SCREEN is visible in the page
  screen.scrollIntoView({ behavior: "smooth", block: "center" });
}

function showAnswerCard(cardData, delta) {
  clearChoiceHotspots();

  const layer = document.getElementById("card-layer");
  const cardEl = document.getElementById("card");

  layer.dataset.delta  = String(delta);
  layer.dataset.cardId = String(cardData.id);

  currentCard = cardData;
  cardMode = "answer";
  cardSide = "front";

  cardEl.classList.remove("flipped");
  layer.style.display = "flex";

  // load + decode before showing (prevents flash/jumble)
  setCardImages({
    frontSrc: cardData.answerFront,
    backSrc:  cardData.answerBack,
    mode: "answer",
    cardData: null
  });
}


function goNextAfterAnswer() {
  if (answeredInThisDeck >= QUESTIONS_PER_DECK) {
    switchToNextDeck();
    return;
  }
  advanceCard();
}

function switchToNextDeck() {
  answeredInThisDeck = 0;

  if (questionPhase === "physical") {
    questionPhase = "emotional";
    activeDeck = MURK_CARDS;
    cardIndex = 0;
    setTimeout(() => showQuestionCard(activeDeck[cardIndex]), NEXT_CARD_DELAY);
    return;
  }

  if (questionPhase === "emotional") {
    questionPhase = "mental";
    activeDeck = MENTAL_CARDS;
    cardIndex = 0;

    // OPTIONAL: if you want Loveland visuals when mental starts:
    // transitionToLoveland(); return;

    setTimeout(() => showQuestionCard(activeDeck[cardIndex]), NEXT_CARD_DELAY);
    return;
  }

  if (questionPhase === "mental") {
    // end of game (or ecstasy bonus if you want)
    setTimeout(() => showJourneyEnd(GameState.land), 700);
    return;
  }
}

function advanceCard() {
  cardIndex++;

  if (cardIndex >= activeDeck.length) {
    console.warn("Past end of deck; forcing deck switch.");
    answeredInThisDeck = QUESTIONS_PER_DECK;
    goNextAfterAnswer();
    return;
  }

  setTimeout(() => showQuestionCard(activeDeck[cardIndex]), NEXT_CARD_DELAY);
}



function transitionToMurkland() {
  // dramatic glow flash
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "murkland";
  GameState.rungIndex = 0;

  // ✅ Murk deck
  activeDeck = MURK_CARDS;
  questionPhase = "emotional";
  // ✅ start Murkland where they left off on emotional questions
  const nextMurkIndex = Math.max(
    0,
    Math.min((typeof murkLastSeenIndex === "number" ? murkLastSeenIndex : -1) + 1, MURK_CARDS.length - 1)
  );
  cardIndex = nextMurkIndex;

  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();

    setTimeout(() => {
      const nextCard = activeDeck[cardIndex];
      if (!nextCard) {
        console.error("No Murk card at index:", cardIndex, "Deck:", activeDeck);
        return;
      }
      showQuestionCard(nextCard);
    }, 1200);
  };

  img.src = "murkland_screen.png";
}
  
function transitionToLoveland() {
  // glow flash (same effect)
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "loveland";
  GameState.rungIndex = 0;

  // ✅ switch to mental deck (Loveland questions)
  // ✅ switch to mental deck (Loveland questions) — RESUME
activeDeck = MENTAL_CARDS;

const nextMentalIndex = Math.max(
  0,
  Math.min((typeof mentalLastSeenIndex === "number" ? mentalLastSeenIndex : -1) + 1, MENTAL_CARDS.length - 1)
);
cardIndex = nextMentalIndex;


  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();
    setTimeout(() => {
      showQuestionCard(activeDeck[cardIndex]);
    }, 1200);
  };

  img.src = "loveland_screen.png";
}

function landLabel(land) {
  const map = {
    darkland: "Darkland",
    murkland: "Murkland",
    loveland: "Loveland",
    ecstasy: "Ecstasy"
  };
  return map[land] || "Loveland";
}

function showJourneyEnd(finalLand) {
  // hide cards
  const layer = document.getElementById("card-layer");
  if (layer) layer.style.display = "none";

  // fade the game screen
  const screen = document.getElementById("game-screen");
  if (screen) {
    screen.style.transition = "opacity 0.9s ease";
    screen.style.opacity = "0";
  }

  // glow overlay
  const end = document.createElement("div");
end.id = "journey-end-overlay";
  end.style.position = "fixed";
  end.style.inset = "0";
  end.style.zIndex = "9999999";
  end.style.display = "flex";
  end.style.alignItems = "center";
  end.style.justifyContent = "center";
  end.style.background = "rgba(0,0,0,0.78)";
  end.style.opacity = "0";
  end.style.transition = "opacity 1.0s ease";

  const msg = document.createElement("div");
  msg.classList.add("journey-impact");
  msg.style.letterSpacing = "3px";
  msg.style.textShadow =
  "0 0 18px rgba(245,255,58,0.95), 0 0 60px rgba(245,255,58,0.45)";
  msg.style.textTransform = "uppercase";
  msg.style.letterSpacing = "2px";
  msg.style.fontSize = "clamp(20px, 3vw, 44px)";
  msg.style.textAlign = "center";
  msg.style.color = "#f5ff3a";
  msg.style.textShadow = "0 0 16px rgba(245,255,58,0.95), 0 0 44px rgba(245,255,58,0.35)";
  msg.style.padding = "24px";
  msg.textContent = `Your journey has brought you to . . . ${landLabel(finalLand)}.`;

  end.appendChild(msg);
  document.body.appendChild(end);

  requestAnimationFrame(() => {
  end.style.opacity = "1";

  // 1️⃣ wait while message is visible
  setTimeout(() => {

    // 2️⃣ fade the text out
    msg.style.transition = "opacity 0.8s ease";
    msg.style.opacity = "0";

    // 3️⃣ after fade finishes, show reflection cards
    setTimeout(() => {
      attachReflectionCards(end, finalLand);
    }, 800);

  }, 2000); // ← your 2 second pause
});
}

function transitionToEcstasy() {
  // glow flash
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  GameState.land = "ecstasy";

  const char = document.getElementById("player-character");
  if (char) char.style.display = "none";

  const img = document.getElementById("game-background");
  if (!img) return;
  img.onload = () => {};
  img.src = "ecstasy_screen.png"; // <-- your file
}


// =============================
// START LOVE GAME
// =============================
// =============================
// START LOVE GAME
// =============================
function startLoveGame() {
  const screen = document.getElementById("game-screen");
  screen.hidden = false;
  screen.style.display = "block";
  // ✅ reset from end-screen fade
  screen.style.opacity = "1";
  screen.style.transition = "none";
  requestAnimationFrame(() => {
    screen.style.transition = ""; // restore normal transitions later if you want
  });

  // ✅ remove any previous journey overlay if it exists
  document.getElementById("journey-end-overlay")?.remove();

  // ✅ make sure character is visible again (ecstasy hides it)
  const char = document.getElementById("player-character");
  if (char) char.style.display = "block";

  GameState.land = "darkland";
  GameState.rungIndex = 0;
  questionPhase = "physical";
lovelandUnlocked = false;
activeDeck = getDeckForPhase();
  answeredInThisDeck = 0;
cardIndex = 0;
murkLastSeenIndex = -1;
mentalLastSeenIndex = -1;
murkTransitionDone = false;
  const img = document.getElementById("game-background");

  // important: clear previous onload (prevents weirdness on replays)
  img.onload = null;
  beginShown = false;
  img.onload = () => {
    const char = document.getElementById("player-character");
    char.src = characterImages[selectedCharacter];
    positionCharacter();
    showBeginText();
    cardIndex = 0;
  };

  img.src = "darkland_screen.png";
}

function showBeginText() {
  if (beginShown) return;
  beginShown = true;

  const begin = document.getElementById("begin-text");
  const img   = document.getElementById("game-background");

  const rung = RUNG_COORDS.darkland[0]; // bottom D

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  begin.style.left = `${x}px`;
  begin.style.top  = `${y - 180}px`;
  begin.style.opacity = 1;
  begin.textContent = "";

  typeWriter(begin, "BEGIN", 120);

  // BEGIN stays visible, then fades
  setTimeout(() => {
    begin.style.transition = "opacity 0.8s ease";
    begin.style.opacity = 0;

    // ✅ AFTER fade finishes, show first card
    setTimeout(() => {
      cardIndex = 0;
showQuestionCard(activeDeck[0]);
    }, 850);

  }, 2800);
}

// Your coordinates
const RUNG_COORDS = {
  darkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  // TODO: replace these with your real murkland rung positions
  murkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  loveland: [
  { x: 904,  y: 1934 },
  { x: 1057, y: 1654 },
  { x: 969,  y: 1380 },
  { x: 1108, y: 1177 },
  { x: 731,  y: 907  },
  { x: 884,  y: 609  },
  { x: 583,  y: 434  },
  { x: 735,  y: 173  }
]
  
};
/* =============================
   REFLECTION CARDS (DRAW + DOWNLOAD)
   Appears inside #journey-end-overlay
============================= */

function attachReflectionCards(endOverlayEl, finalLand) {
  const DPR = window.devicePixelRatio || 1;

  if (endOverlayEl.querySelector(".reflection-wrap")) return;

  const wrap = document.createElement("div");
  wrap.className = "reflection-wrap";

  const stage = document.createElement("div");
  stage.className = "reflection-cardstage";

  const topRow = document.createElement("div");
  topRow.className = "reflection-toprow";

  const title = document.createElement("div");
  title.className = "reflection-title";
  title.textContent = "Reflection Cards";

  const tabs = document.createElement("div");
  tabs.className = "reflection-tabs";

  const btnFront = document.createElement("button");
  btnFront.type = "button";
  btnFront.className = "reflection-tabbtn active";
  btnFront.textContent = "FRONT";

  const btnBack = document.createElement("button");
  btnBack.type = "button";
  btnBack.className = "reflection-tabbtn";
  btnBack.textContent = "BACK";

  tabs.appendChild(btnFront);
  tabs.appendChild(btnBack);

  topRow.appendChild(title);
  topRow.appendChild(tabs);

  // ---- Base canvases (template + drawing) ----
  const canvasFront = document.createElement("canvas");
  canvasFront.className = "reflection-canvas";


  const canvasBack = document.createElement("canvas");
  canvasBack.className = "reflection-canvas";

  canvasBack.style.display = "none";

  // ---- Text overlay canvases (movable text lives here) ----
  const textFront = document.createElement("canvas");
  textFront.className = "reflection-canvas reflection-textlayer";
  textFront.width = canvasFront.width;
  textFront.height = canvasFront.height;

  const textBack = document.createElement("canvas");
  textBack.className = "reflection-canvas reflection-textlayer";
  textBack.width = canvasBack.width;
  textBack.height = canvasBack.height;
  textBack.style.display = "none";

function setupHiDPICanvas(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();

  canvas.width  = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);

  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  return ctx;
}



  stage.appendChild(topRow);

  // Important order: base first, then overlay on top
  stage.appendChild(canvasFront);
  stage.appendChild(textFront);

  stage.appendChild(canvasBack);
  stage.appendChild(textBack);

  // ---- Controls ----
  const controls = document.createElement("div");
  controls.className = "reflection-controls";

  const h = document.createElement("h3");
  h.textContent = "Draw + Download";
  controls.appendChild(h);

  const row1 = document.createElement("div");
  row1.className = "reflection-row";

  const colorLabel = document.createElement("label");
  colorLabel.textContent = "Color:";
  const colorInput = document.createElement("input");
  colorInput.type = "color";
  colorInput.value = "#fd11b4";

  const sizeLabel = document.createElement("label");
  sizeLabel.textContent = "Brush:";
  const sizeInput = document.createElement("input");
  sizeInput.type = "range";
  sizeInput.min = "2";
  sizeInput.max = "40";
  sizeInput.value = "10";

  row1.appendChild(colorLabel);
  row1.appendChild(colorInput);
  row1.appendChild(sizeLabel);
  row1.appendChild(sizeInput);

  const rowText = document.createElement("div");
  rowText.className = "reflection-row";

  const textBtn = document.createElement("button");
  textBtn.type = "button";
  textBtn.className = "reflection-btn secondary";
  textBtn.textContent = "TEXT TOOL: OFF";

  const textInput = document.createElement("input");
  textInput.type = "text";
  textInput.placeholder = "Type text, then click card to place / drag";
  textInput.style.flex = "1";
  textInput.style.padding = "10px";
  textInput.style.borderRadius = "10px";

  const textSize = document.createElement("input");
  textSize.type = "range";
  textSize.min = "18";
  textSize.max = "140";
  textSize.value = "60";

  rowText.appendChild(textBtn);
  rowText.appendChild(textInput);
  rowText.appendChild(textSize);

  const row2 = document.createElement("div");
  row2.className = "reflection-row";

  const eraserBtn = document.createElement("button");
  eraserBtn.type = "button";
  eraserBtn.className = "reflection-btn secondary";
  eraserBtn.textContent = "ERASER: OFF";

  const clearBtn = document.createElement("button");
  clearBtn.type = "button";
  clearBtn.className = "reflection-btn danger";
  clearBtn.textContent = "CLEAR SIDE";

  row2.appendChild(eraserBtn);
  row2.appendChild(clearBtn);

  const row3 = document.createElement("div");
  row3.className = "reflection-row";

  const dlFront = document.createElement("button");
  dlFront.type = "button";
  dlFront.className = "reflection-btn";
  dlFront.textContent = "DOWNLOAD FRONT";

  const dlBack = document.createElement("button");
  dlBack.type = "button";
  dlBack.className = "reflection-btn";
  dlBack.textContent = "DOWNLOAD BACK";

  const dlBoth = document.createElement("button");
  dlBoth.type = "button";
  dlBoth.className = "reflection-btn secondary";
  dlBoth.textContent = "DOWNLOAD BOTH";

  row3.appendChild(dlFront);
  row3.appendChild(dlBack);
  row3.appendChild(dlBoth);

  controls.appendChild(row1);
  controls.appendChild(rowText);
  controls.appendChild(row2);
  controls.appendChild(row3);

  wrap.appendChild(stage);
  wrap.appendChild(controls);
  endOverlayEl.appendChild(wrap);

  // ---- State ----
  const state = {
    active: "front",
    tool: "draw", // "draw" | "text"
    eraser: false,
    color: colorInput.value,
    size: Number(sizeInput.value),
    text: "",
    textSize: Number(textSize.value),
  };

 let ctxF, ctxB, tCtxF, tCtxB;   

  const templates = { front: "reflection_front.png", back: "reflection_back.png" };

  function drawTemplate(which) {
    const canvasEl = which === "front" ? canvasFront : canvasBack;
    const ctx = which === "front" ? ctxF : ctxB;

    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

      // White base
      ctx.save();
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
      ctx.restore();

      // CONTAIN (no stretch, no crop)
      const iw = img.width, ih = img.height;
      const cw = canvasEl.width, ch = canvasEl.height;
      const scale = Math.min(cw / iw, ch / ih);
      const dw = iw * scale, dh = ih * scale;
      const dx = (cw - dw) / 2;
      const dy = (ch - dh) / 2;

      ctx.drawImage(img, dx, dy, dw, dh);
    };
    img.src = templates[which];
  }

  drawTemplate("front");
  drawTemplate("back");

  // ---- Text drawing (overlay only) ----
  function drawTextAt(ctx, x, y, text, color, sizePx) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${sizePx}px Georgia, 'Times New Roman', serif`;
    ctx.textBaseline = "top";

    const lines = String(text).split("\n");
    const lineH = Math.round(sizePx * 1.15);
    lines.forEach((line, i) => ctx.fillText(line, x, y + i * lineH));

    ctx.restore();
  }

  const textItems = { front: [], back: [] };
  let dragging = null;
  let dragOff = { x: 0, y: 0 };

  function getTextCtx(which) { return which === "front" ? tCtxF : tCtxB; }
  function getTextCanvas(which) { return which === "front" ? textFront : textBack; }

  function getTextBounds(ctx, item) {
    ctx.save();
    ctx.font = `${item.size}px Georgia, 'Times New Roman', serif`;
    const lines = item.text.split("\n");
    const lineH = item.size * 1.15;

    let w = 0;
    for (const line of lines) w = Math.max(w, ctx.measureText(line).width);
    const h = lines.length * lineH;

    ctx.restore();
    return { x: item.x, y: item.y, w, h };
  }

  function repaintText(which) {
    const tctx = getTextCtx(which);
    const tcan = getTextCanvas(which);
    tctx.clearRect(0, 0, tcan.width, tcan.height);

    for (const item of textItems[which]) {
      drawTextAt(tctx, item.x, item.y, item.text, item.color, item.size);
    }
  }

  // ---- Tab switching ----
  function setActive(which) {
  state.active = which;

  btnFront.classList.toggle("active", which === "front");
  btnBack.classList.toggle("active", which === "back");

  canvasFront.style.display = which === "front" ? "block" : "none";
  textFront.style.display   = which === "front" ? "block" : "none";
  canvasBack.style.display  = which === "back"  ? "block" : "none";
  textBack.style.display    = which === "back"  ? "block" : "none";

  const baseCanvas = which === "front" ? canvasFront : canvasBack;
  const textCanvas = which === "front" ? textFront : textBack;

  ctxF  = setupHiDPICanvas(canvasFront);
  ctxB  = setupHiDPICanvas(canvasBack);
  tCtxF = setupHiDPICanvas(textFront);
  tCtxB = setupHiDPICanvas(textBack);

  ctxF.lineCap = ctxB.lineCap = "round";
  ctxF.lineJoin = ctxB.lineJoin = "round";

  drawTemplate(which);
  repaintText(which);
}


  btnFront.addEventListener("click", () => setActive("front"));
  btnBack.addEventListener("click", () => setActive("back"));

  // ---- Control listeners ----
  colorInput.addEventListener("input", () => state.color = colorInput.value);
  sizeInput.addEventListener("input", () => state.size = Number(sizeInput.value));

  eraserBtn.addEventListener("click", () => {
    state.eraser = !state.eraser;
    eraserBtn.textContent = state.eraser ? "ERASER: ON" : "ERASER: OFF";
  });

  clearBtn.addEventListener("click", () => {
    drawTemplate(state.active);
    textItems[state.active] = [];
    repaintText(state.active);
  });

  textInput.addEventListener("input", () => state.text = textInput.value || "");
  textSize.addEventListener("input", () => state.textSize = Number(textSize.value));

  textBtn.addEventListener("click", () => {
    const on = state.tool !== "text";
    state.tool = on ? "text" : "draw";
    textBtn.textContent = on ? "TEXT TOOL: ON" : "TEXT TOOL: OFF";
    if (on) {
      state.eraser = false;
      eraserBtn.textContent = "ERASER: OFF";
    }
  });

  // ---- Download (merge base + text overlay) ----
  function downloadCanvas(which) {
    const base = which === "front" ? canvasFront : canvasBack;
    const text = which === "front" ? textFront : textBack;

    const out = document.createElement("canvas");
    out.width = base.width;
    out.height = base.height;

    const octx = out.getContext("2d");
    octx.drawImage(base, 0, 0);
    octx.drawImage(text, 0, 0);

    const a = document.createElement("a");
    const safeLand = (finalLand || "result").toString().toLowerCase();
    a.download = `lovegame_reflection_${safeLand}_${which}.png`;
    a.href = out.toDataURL("image/png");
    a.click();
  }

  dlFront.addEventListener("click", () => downloadCanvas("front"));
  dlBack.addEventListener("click", () => downloadCanvas("back"));
  dlBoth.addEventListener("click", () => {
    downloadCanvas("front");
    setTimeout(() => downloadCanvas("back"), 250);
  });

  // ---- Input handling (attach to TEXT overlay canvases only) ----
  let drawing = false;
  let last = null;

function getPos(canvas, evt) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}







function down(evt) {
  evt.preventDefault();

  const which = state.active;
  const baseCanvas = which === "front" ? canvasFront : canvasBack;
  const p = getPos(baseCanvas, evt);

  // text drag check stays the same
  const tctx = getTextCtx(which);
  for (let i = textItems[which].length - 1; i >= 0; i--) {
    const item = textItems[which][i];
    const b = getTextBounds(tctx, item);
    if (p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h) {
      dragging = item;
      dragOff.x = p.x - item.x;
      dragOff.y = p.y - item.y;
      return;
    }
  }

  if (state.tool === "text") {
    if (state.text.trim()) {
      textItems[which].push({
        x: p.x,
        y: p.y,
        text: state.text,
        color: state.color,
        size: state.textSize
      });
      repaintText(which);
    }
    return;
  }

  drawing = true;
  last = p;          // ✅ SAME canvas space
}



 function move(evt) {
  if (dragging) {
    evt.preventDefault();
    const which = state.active;
    const tcan = getTextCanvas(which);
    const p = getPos(tcan, evt);

    dragging.x = p.x - dragOff.x;
    dragging.y = p.y - dragOff.y;
    repaintText(which);
    return;
  }

  if (!drawing || !last) return;
  evt.preventDefault();

  const which = state.active;
  const ctx = which === "front" ? ctxF : ctxB;
  const canvas = which === "front" ? canvasFront : canvasBack;
  const p = getPos(canvas, evt); // ✅ SAME canvas as last

  ctx.save();
  ctx.lineWidth = state.size;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  if (state.eraser) {
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "#000";
  } else {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = state.color;
  }

  ctx.beginPath();
  ctx.moveTo(last.x, last.y);
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  ctx.restore();

  last = p;          // ✅ update in same space
}

  
function up() {
  dragging = null;
  drawing = false;
  last = null;

  window.removeEventListener("mousemove", move);
  window.removeEventListener("touchmove", move);
}




  [textFront, textBack].forEach((c) => {
  c.addEventListener("mousedown", (e) => {
    down(e);
    window.addEventListener("mousemove", move);
    window.addEventListener("mouseup", up, { once: true });
  });

  c.addEventListener("touchstart", (e) => {
    down(e);
    window.addEventListener("touchmove", move, { passive: false });
    window.addEventListener("touchend", up, { once: true });
    window.addEventListener("touchcancel", up, { once: true });
  }, { passive: false });
});


  // Ensure initial view is correct
  setActive("front");
}



</script>
</body>
</html>
