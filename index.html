<!DOCTYPE html>
<html lang="en">
<head>
  <title>Love Game</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<canvas id="mouse-canvas"></canvas>

<div class="header">
  <h1>Love Game</h1>
  <p>~ A Quest to Assess your Mental, Physical, and Emotional Health ~</p>
</div>

<div class="navbar">
  <a href="index.html">Play</a>
  <a href="about.html">About</a>
  <a href="#">Community</a>
<!-- <a href="#" class="right">Log In</a> -->
</div>
  
<div id="intro-overlay">
  <canvas id="starfield"></canvas>
  <div id="intro-text" class="cyber-text">ENTERING CYBERSPACE <span id="loading-dots"></span></div>
</div>
<!-- SECOND SCREEN: REMINDERS -->
<div id="reminder-overlay" hidden>
  <div class="reminder-box">

  <!-- REMINDERS (visible first) -->
  <div id="reminders-content">
    <h2>REMINDERS</h2>
    <ol class="reminder-list">
      <li>Be as truthful as possible (to ensure that your final result truly reflects your current health!)</li>
      <li>Play whenever you wish to reassess your wellbeing status . . .</li>
      <li>Should you land in a territory that concerns you, apply balanced Self and External love â€” and return later.</li>
      <li>Societal factors, including racial bias, socioeconomic barriers, and gender identity, may influence outcomes.</li>
      <li><strong>Ecstasy</strong> â€” The highest realm where energy and love abound.</li>
      <li><strong>Loveland</strong> â€” Balance exists, though some Murktivities linger.</li>
      <li><strong>Murkland</strong> â€” Clouded energy causes fluctuating health.</li>
      <li><strong>Darkland</strong> â€” A pit where murk compounds into darkness.</li>
    </ol>
  </div>

  <!-- Arrow -->
  <div id="rules-arrow" aria-label="Show rules">âžœ</div>

  <!-- RULES (hidden initially) -->
  <div id="rules-content" hidden>
    <h2>RULES</h2>
    <ol class="reminder-list">
      <li>Click the card presented and answer its question.</li>
      <li>If you answer in a way that shows balanced Self and External love, your character will move up.</li>
      <li>If you answer in a way that shows an imbalance of Self and External love, your character will move down.</li>
      <li>Enough balanced answers will move your character into <strong>Loveland</strong>, and eventually, <strong>Ecstasy</strong> (without narcotics!).</li>
      <li>Enough imbalanced answers will move your character into <strong>Murkland</strong>, and eventually, <strong>Darkland</strong>.</li>
    </ol>
  </div>

  <!-- BUTTON (hidden initially) -->
  <button id="start-game" hidden>FOR SURE :)</button>

</div>

</div>

<!-- CHARACTER SELECT SCREEN -->
<div id="character-overlay" class="hidden">
  <h2 class="character-title">Choose Your Character</h2>

  <div class="character-grid">
    <img src="char1.png" class="character" data-char="1">
    <img src="char2.png" class="character" data-char="2">
    <img src="char3.png" class="character" data-char="3">
    <img src="char4.png" class="character" data-char="4">
    <img src="char5.png" class="character" data-char="5">
  </div>

  <button id="confirm-character" disabled>CONFIRM</button>
</div>

<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="side-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.03 0.15" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
    <filter id="top-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.15 0.03" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
  </defs>
</svg>
  
<script>
/* --- UNIVERSAL MOUSE STREAK SETUP --- */
const mCanvas = document.getElementById("mouse-canvas");
const mCtx = mCanvas.getContext("2d");
let mPoints = [];
const TRAIL_LIFESPAN = 12; // Shortened slightly to reduce lag

function resizeCanvases() {
  mCanvas.width = canvas.width = window.innerWidth;
  mCanvas.height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvases);

window.addEventListener("mousemove", (e) => {
  mPoints.push({ x: e.clientX, y: e.clientY, age: 0 });
});

/* --- INTRO STARFIELD SETUP --- */
const starColors = [[255, 255, 255], [200, 220, 255], [220, 200, 255], [255, 230, 180], [180, 255, 240]];
const overlay = document.getElementById("intro-overlay");
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");

let stars = [];
let shootingStars = []; 
let fireEmbers = [];    
let running = true;

/* Initialize Stars */
function createStars(count = 120) { // Slightly fewer stars for better performance
  stars = [];
  for (let i = 0; i < count; i++) {
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    stars.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: Math.random() * 1.4 + 0.3,
      speed: Math.random() * 0.12 + 0.05,
      color
    });
  }
}
createStars();

/* --- THE OPTIMIZED MERGED LOOP --- */
function animate() {
  // Clear both canvases
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  if (running) ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Draw Mouse Streak First (Optimization: Only one shadow call)
  if (mPoints.length > 1) {
    mCtx.shadowBlur = 8; // Lower value = faster performance
    mCtx.shadowColor = "#f5ff3a";
    mCtx.lineCap = "round";
    mCtx.lineJoin = "round";

    for (let i = 1; i < mPoints.length; i++) {
      const p1 = mPoints[i - 1];
      const p2 = mPoints[i];
      const opacity = 1 - (p1.age / TRAIL_LIFESPAN);
      
      mCtx.strokeStyle = `rgba(245, 255, 58, ${opacity})`; 
      mCtx.lineWidth = opacity * 5;
      
      mCtx.beginPath();
      mCtx.moveTo(p1.x, p1.y);
      mCtx.lineTo(p2.x, p2.y);
      mCtx.stroke();
      p1.age++;
    }
    mCtx.shadowBlur = 0; // Turn it off immediately for other elements
  }
  mPoints = mPoints.filter(p => p.age < TRAIL_LIFESPAN);

  // 2. Draw Intro Elements Only If Running
  if (running) {
    /* Background Stars */
    stars.forEach(star => {
      star.y += star.speed;
      if (star.y > canvas.height) star.y = 0;
      ctx.fillStyle = `rgba(${star.color[0]}, ${star.color[1]}, ${star.color[2]}, 0.8)`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    });

    /* Background Shooting Stars (White) */
    shootingStars.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) shootingStars.splice(i, 1);
    });

    /* Border Embers (Orange) */
    fireEmbers.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = "#ff8c00";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) fireEmbers.splice(i, 1);
    });

    /* Spawn Logic */
    if (Math.random() > 0.85) spawnEmbers();
  }

  requestAnimationFrame(animate);
}

function spawnEmbers() {
  const side = Math.floor(Math.random() * 4);
  let ex, ey, evx, evy;
  if (side === 0) { ex = Math.random()*canvas.width; ey = 0; evx = (Math.random()-0.5)*2; evy = Math.random()*4; } 
  else if (side === 1) { ex = Math.random()*canvas.width; ey = canvas.height; evx = (Math.random()-0.5)*2; evy = -Math.random()*4; } 
  else if (side === 2) { ex = 0; ey = Math.random()*canvas.height; evx = Math.random()*4; evy = (Math.random()-0.5)*2; } 
  else { ex = canvas.width; ey = Math.random()*canvas.height; evx = -Math.random()*4; evy = (Math.random()-0.5)*2; }
  fireEmbers.push({ x: ex, y: ey, vx: evx, vy: evy, life: 0 });
}

// Shooting star interval logic
function createShootingStar() {
  const c = starColors[Math.floor(Math.random() * starColors.length)];
  shootingStars.push({
    x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.5,
    vx: Math.random() * 7 + 5, vy: Math.random() * 3 + 2,
    life: 0, color: `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`
  });
}
const shootingInterval = setInterval(() => { if (Math.random() > 0.4) createShootingStar(); }, 300);

/* End Intro Logic */
function endIntro() {
  running = false;
  clearInterval(shootingInterval);
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";
  setTimeout(() => overlay.remove(), 600);
}

const timeout = setTimeout(endIntro, 3500);
/* --- Improved Skip Logic --- */

// 1. Click to Skip
overlay.addEventListener("click", () => {
  clearTimeout(timeout);
  endIntro();
}, { once: true });

// 2. Keypress to Skip (Now targeting the whole window)
window.addEventListener("keydown", (e) => {
  // This ensures the intro ends regardless of which key is pressed
  clearTimeout(timeout);
  endIntro();
}, { once: true });

/* --- End Intro Logic (Ensure this matches) --- */
function endIntro() {
  if (!running && !overlay.parentNode) return; // Prevent running twice
  
  running = false;
  clearInterval(shootingInterval);
  
  // Smooth Fade Out
  overlay.style.transition = "opacity 0.8s ease, visibility 0.8s";
  overlay.style.opacity = "0";
  overlay.style.visibility = "hidden";
  
  // Completely remove from memory after fade
  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
  }, 800);
}
resizeCanvases();
animate();
  
const dotsElement = document.getElementById('loading-dots');
let dotCount = 0;

const dotInterval = setInterval(() => {
  dotCount = (dotCount + 1) % 4; 
  // Adding a space after the dot inside the repeat function
  if(dotsElement) dotsElement.textContent = ". ".repeat(dotCount);
}, 400);

/* Update your endIntro function to stop the dots too */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();

    // ðŸ”¥ SHOW SECOND SCREEN HERE
    enableReminderSkip();


  }, 600);
}
/* =============================
   REMINDERS â†’ RULES â†’ START FLOW
============================= */

function enableReminderScreen() {
  const reminderOverlay = document.getElementById("reminder-overlay");
  const reminders = document.getElementById("reminders-content");
  const rules = document.getElementById("rules-content");
  const arrow = document.getElementById("rules-arrow");
  const startBtn = document.getElementById("start-game");

  if (!reminderOverlay || !reminders || !rules || !arrow || !startBtn) return;

  // Show reminders
  reminderOverlay.hidden = false;
  reminderOverlay.style.opacity = "0";
  requestAnimationFrame(() => {
    reminderOverlay.style.transition = "opacity 0.4s ease";
    reminderOverlay.style.opacity = "1";
  });

  // ------------------------
  // STEP 1: Click or key on reminders â†’ show rules
  function showRules() {
    reminders.style.display = "none";
    rules.hidden = false;
    startBtn.hidden = false;
    arrow.style.display = "none";

    // Remove listeners for showing rules
    reminderOverlay.removeEventListener("click", showRules);
    window.removeEventListener("keydown", showRules);

    // Enable closing the rules screen
    enableRulesClose();
  }

  reminderOverlay.addEventListener("click", showRules);
  window.addEventListener("keydown", showRules);

  // Keep arrow clickable as alternative
  arrow.addEventListener("click", (e) => {
    e.stopPropagation();
    showRules();
  });
}

/* ------------------------
   STEP 2: Close overlay from rules
------------------------ */
function closeRules() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  overlay.style.transition = "opacity 0.5s ease";
  overlay.style.opacity = "0";

  // Remove listeners immediately to prevent double triggers
  window.removeEventListener("keydown", closeRules);
  overlay.removeEventListener("click", closeRules);

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove(); showCharacterSelect();
  }, 500);
}

function enableRulesClose() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  // Click anywhere OR any key closes the rules overlay
  overlay.addEventListener("click", closeRules);
  window.addEventListener("keydown", closeRules);

  // Also allow button to close
  document.getElementById("start-game")?.addEventListener("click", closeRules);
}

/* ------------------------
   STEP 3: Call this after intro ends
------------------------ */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
    // ðŸ”¥ SHOW REMINDERS SCREEN ONLY NOW
    enableReminderScreen();
  }, 600);
}
/* =============================
   CHARACTER SELECT LOGIC
============================= */
/* =============================
   CHARACTER SELECT LOGIC
============================= */

let selectedCharacter = null;

function showCharacterSelect() {
  const overlay = document.getElementById("character-overlay");
  overlay.classList.remove("hidden");    // Make overlay visible
  overlay.style.opacity = "1";           // Fully visible
  overlay.style.pointerEvents = "auto";  // Allow clicks
}

const characters = document.querySelectorAll(".character");

characters.forEach(char => {
  char.addEventListener("click", () => {
    const overlay = document.getElementById("character-overlay");

    // Clear previous state
    characters.forEach(c => c.classList.remove("selected", "dimmed"));

    // Select current
    char.classList.add("selected");
    selectedCharacter = char.dataset.char;
    confirmBtn.disabled = false;

    // Dim others
    characters.forEach(c => {
      if (c !== char) c.classList.add("dimmed");
    });

    // Soft fade of screen
    overlay.classList.add("selection-made");
  });
});

// âœ… CONFIRM BUTTON â€” THIS WAS MISSING
const confirmBtn = document.getElementById("confirm-character");

confirmBtn.addEventListener("click", () => {
  if (!selectedCharacter) return;

  const overlay = document.getElementById("character-overlay");

  // Fade out
  overlay.classList.add("fade-out");  // triggers opacity 0 + disables clicks

  setTimeout(() => {
    overlay.remove();                  // remove overlay after fade
    console.log("Character chosen:", selectedCharacter);
    // ðŸ”¥ Start your game here
  }, 800);
});


</script>
</script>
</body>
</html>
