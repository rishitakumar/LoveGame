<!DOCTYPE html>
<html lang="en">
<head>
  <title>Love Game</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<canvas id="mouse-canvas"></canvas>

<div class="header">
  <h1>Love Game</h1>
  <p>~ A Quest to Assess your Mental, Physical, and Emotional Health ~</p>
</div>

<div class="navbar">
  <a href="index.html">Play</a>
  <a href="about.html">About</a>
  <a href="#">Community</a>
<!-- <a href="#" class="right">Log In</a> -->
</div>
  
<div id="intro-overlay">
  <canvas id="starfield"></canvas>
  <div id="intro-text" class="cyber-text">ENTERING CYBERSPACE <span id="loading-dots"></span></div>
</div>
<!-- SECOND SCREEN: REMINDERS -->
<div id="reminder-overlay" hidden>
  <div class="reminder-box">

  <!-- REMINDERS (visible first) -->
  <div id="reminders-content">
    <h2>REMINDERS</h2>
    <ol class="reminder-list">
      <li>Be as truthful as possible (to ensure that your final result truly reflects your current health!)</li>
      <li>Play whenever you wish to reassess your wellbeing status . . .</li>
      <li>Should you land in a territory that concerns you, apply balanced Self and External love — and return later.</li>
      <li>Societal factors, including racial bias, socioeconomic barriers, and gender identity, may influence outcomes.</li>
      <li><strong>Ecstasy</strong> — The highest realm where energy and love abound.</li>
      <li><strong>Loveland</strong> — Balance exists, though some Murktivities linger.</li>
      <li><strong>Murkland</strong> — Clouded energy causes fluctuating health.</li>
      <li><strong>Darkland</strong> — A pit where murk compounds into darkness.</li>
    </ol>
  </div>

  <!-- Arrow -->
  <div id="rules-arrow" aria-label="Show rules">➜</div>

  <!-- RULES (hidden initially) -->
  <div id="rules-content" hidden>
    <h2>RULES</h2>
    <ol class="reminder-list">
      <li>Click the card presented and answer its question.</li>
      <li>If you answer in a way that shows balanced Self and External love, your character will move up.</li>
      <li>If you answer in a way that shows an imbalance of Self and External love, your character will move down.</li>
      <li>Enough balanced answers will move your character into <strong>Loveland</strong>, and eventually, <strong>Ecstasy</strong> (without narcotics!).</li>
      <li>Enough imbalanced answers will move your character into <strong>Murkland</strong>, and eventually, <strong>Darkland</strong>.</li>
    </ol>
  </div>

  <!-- BUTTON (hidden initially) -->
  <button id="start-game" hidden>FOR SURE :)</button>

</div>

</div>

<!-- CHARACTER SELECT SCREEN -->
<div id="character-overlay" class="hidden">
  <div id="character-caption" class="hidden"></div>
  <h2 class="character-title">CHOOSE YOUR CHARACTER!</h2>

  <div class="character-grid">
    <img src="1phoenix.png" class="character" data-character="phoenix">
    <img src="2kitsune.png" class="character" data-character="kitsune">
    <img src="3wata.png" class="character" data-character="mamiwata">
    <img src="4hydra.png" class="character" data-character="hydra">
    <img src="5girl.png" class="character" data-character="human">

  </div>

  <button id="confirm-character" disabled>CONFIRM</button>
</div>

<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="side-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.03 0.15" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
    <filter id="top-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.15 0.03" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
  </defs>
</svg>

 <div id="game-screen" hidden>
    <div id="card-layer">
  <div id="card" class="card">
    <img id="card-front">
    <img id="card-back">
  </div>
</div>
  <div id="board">
    <div id="ladder-wrapper">
      <img id="game-background" />
      <img id="player-character" />
      <div id="begin-text" class="begin-text"></div>
    </div>
  </div>

  <div id="card-container"></div>
</div>
  
<script>
// =============================
// DAILY PLAY LIMIT
// =============================
 /* const todayKey = new Date().toDateString();

if (localStorage.getItem("lovegame-played") === todayKey) {
  document.body.innerHTML = `
    <div class="cyber-text" style="text-align:center; margin-top:40vh;">
      Come back tomorrow, fellow traveler . . .
    </div>
  `;
  throw new Error("Daily limit reached");
}

localStorage.setItem("lovegame-played", todayKey); --- */


let beginShown = false;

// =============================
// CARD DATA (QUESTIONS + ANSWERS)
// =============================

const PHYSICAL_CARDS = [
  {
    id: 1,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q1_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a1_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c:  0,
      d: +1,
      e: +1
    }
  },

  {
    id: 2,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q2_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a2_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c: -1,
      d: +1,
      e: +1
    }
  },
  
{
    id: 3,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q3_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a3_back.png",

    outcomes: {
      a: 0,
      b: -1,
      c: +1,
      d: +1
    }
  },

{
    id: 4,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q4_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a4_back.png",

    outcomes: {
      a: +1,
      b: +1,
      c: -1,
      d: 0
    }
  },
  
  {
    id: 5,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q5_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a5_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: +1
    }
  },

  {
    id: 6,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q6_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a6_back.png",

    outcomes: {
      a: +1,
      b: 0,
      c: -1,
      d: +1
    }
  },

  {
    id: 7,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q7_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a7_back.png",

    outcomes: {
      a: 0,
      b: +1,
      c: -1,
      d: -1
    }
  },

  {
    id: 8,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q8_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a8_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: -1
    }
  }
  // add up to 8
];

// -----------------------------
// MURKLAND CARDS (make your own)
// -----------------------------
const MURK_CARDS = [
  {
    id: 101,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q1_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a1_back.png",
    outcomes: { 
      a:-1, b:0, c:+1
    }
  },
  
{
    id: 102,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q2_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a2_back.png",
    outcomes: { 
      a:+1, b:0, c:+1, d:-1, e:-1
    }
  },

{
    id: 103,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q3_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a3_back.png",
    outcomes: { 
      a:-1, b:-1, c:+1, d:0, e:+1
    }
  },

  {
    id: 104,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q4_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a4_back.png",
    outcomes: { 
      a:+1, b:+1, c:+1, d:-1
    }
  },

    {
    id: 105,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q5_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a5_back.png",
    outcomes: { 
      a:-1, b:0, c:0, d:+1
    }
  },

  {
    id: 106,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q6_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a6_back.png",
    outcomes: { 
      a:+1, b:+1, c:0, d:-1
    }
  },

  {
    id: 107,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q7_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a7_back.png",
    outcomes: { 
      a:0, b:+1, c:-1, d:+1, e:-1
    }
  },
  
{
    id: 108,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q8_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a8_back.png",
    outcomes: { 
      a:+1, b:0, c:-1, d:+1
    }
  },
  
  // add more...
];

// -----------------------------
// LOVELAND CARDS (MENTAL)
// -----------------------------
const MENTAL_CARDS = [
  {
    id: 201,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q1_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a1_back.png",
    outcomes: { a:-1, b:+1, c:0, d:-1 }
  },
  
  {
    id: 202,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q2_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a2_back.png",
    outcomes: { a:-1, b:0, c:+1, d:-1 }
  },

  {
    id: 203,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q3_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a3_back.png",
    outcomes: { a:0, b:+1, c:0, d:-1 }
  },

  {
    id: 204,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q4_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a4_back.png",
    outcomes: { a:-1, b:+1, c:0, d:-1 }
  },

  {
    id: 205,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q5_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a5_back.png",
    outcomes: { a:-1, b:-1, c:0, d:+1, e:-1}
  },

  {
    id: 206,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q6_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a6_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:+1, e:0}
  },

  {
    id: 207,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q7_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a7_back.png",
    outcomes: { a:+1, b:0, c:+1, d:-1}
  },

  {
    id: 208,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q8_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a8_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:0, e:0}
  }
  // add more...
];

function getDeckForPhase() {
  if (questionPhase === "physical") return PHYSICAL_CARDS;
  if (questionPhase === "emotional") return MURK_CARDS;
  if (questionPhase === "mental") return MENTAL_CARDS;
  return PHYSICAL_CARDS;
}


  
function getActiveDeck() {
  // Murkland screen uses Murk-only
  if (GameState.land === "murkland") return MURK_CARDS;

  // Darkland screen can still ask emotional (Murk) questions,
  // BUT we do NOT show Murkland visuals yet.
  if (GameState.land === "darkland") return [...PHYSICAL_CARDS, ...MURK_CARDS];

  return PHYSICAL_CARDS; // fallback
}


// -----------------------------
// ACTIVE DECK + TRANSITION FLAG
// -----------------------------
let activeDeck = PHYSICAL_CARDS;
let murkTransitionDone = false;

  
/* --- UNIVERSAL MOUSE STREAK SETUP --- */
const mCanvas = document.getElementById("mouse-canvas");
const mCtx = mCanvas.getContext("2d");
let mPoints = [];
const TRAIL_LIFESPAN = 12; // Shortened slightly to reduce lag

function resizeCanvases() {
  mCanvas.width = canvas.width = window.innerWidth;
  mCanvas.height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvases);

window.addEventListener("mousemove", (e) => {
  mPoints.push({ x: e.clientX, y: e.clientY, age: 0 });
});

/* --- INTRO STARFIELD SETUP --- */
const starColors = [[255, 255, 255], [200, 220, 255], [220, 200, 255], [255, 230, 180], [180, 255, 240]];
const overlay = document.getElementById("intro-overlay");
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");

let stars = [];
let shootingStars = []; 
let fireEmbers = [];    
let running = true;

/* Initialize Stars */
function createStars(count = 120) { // Slightly fewer stars for better performance
  stars = [];
  for (let i = 0; i < count; i++) {
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    stars.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: Math.random() * 1.4 + 0.3,
      speed: Math.random() * 0.12 + 0.05,
      color
    });
  }
}
createStars();

/* --- THE OPTIMIZED MERGED LOOP --- */
function animate() {
  // Clear both canvases
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  if (running) ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Draw Mouse Streak First (Optimization: Only one shadow call)
  if (mPoints.length > 1) {
    mCtx.shadowBlur = 8; // Lower value = faster performance
    mCtx.shadowColor = "#f5ff3a";
    mCtx.lineCap = "round";
    mCtx.lineJoin = "round";

    for (let i = 1; i < mPoints.length; i++) {
      const p1 = mPoints[i - 1];
      const p2 = mPoints[i];
      const opacity = 1 - (p1.age / TRAIL_LIFESPAN);
      
      mCtx.strokeStyle = `rgba(245, 255, 58, ${opacity})`; 
      mCtx.lineWidth = opacity * 5;
      
      mCtx.beginPath();
      mCtx.moveTo(p1.x, p1.y);
      mCtx.lineTo(p2.x, p2.y);
      mCtx.stroke();
      p1.age++;
    }
    mCtx.shadowBlur = 0; // Turn it off immediately for other elements
  }
  mPoints = mPoints.filter(p => p.age < TRAIL_LIFESPAN);

  // 2. Draw Intro Elements Only If Running
  if (running) {
    /* Background Stars */
    stars.forEach(star => {
      star.y += star.speed;
      if (star.y > canvas.height) star.y = 0;
      ctx.fillStyle = `rgba(${star.color[0]}, ${star.color[1]}, ${star.color[2]}, 0.8)`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    });

    /* Background Shooting Stars (White) */
    shootingStars.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) shootingStars.splice(i, 1);
    });

    /* Border Embers (Orange) */
    fireEmbers.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = "#ff8c00";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) fireEmbers.splice(i, 1);
    });

    /* Spawn Logic */
    if (Math.random() > 0.85) spawnEmbers();
  }

  requestAnimationFrame(animate);
}

function spawnEmbers() {
  const side = Math.floor(Math.random() * 4);
  let ex, ey, evx, evy;
  if (side === 0) { ex = Math.random()*canvas.width; ey = 0; evx = (Math.random()-0.5)*2; evy = Math.random()*4; } 
  else if (side === 1) { ex = Math.random()*canvas.width; ey = canvas.height; evx = (Math.random()-0.5)*2; evy = -Math.random()*4; } 
  else if (side === 2) { ex = 0; ey = Math.random()*canvas.height; evx = Math.random()*4; evy = (Math.random()-0.5)*2; } 
  else { ex = canvas.width; ey = Math.random()*canvas.height; evx = -Math.random()*4; evy = (Math.random()-0.5)*2; }
  fireEmbers.push({ x: ex, y: ey, vx: evx, vy: evy, life: 0 });
}

// Shooting star interval logic
function createShootingStar() {
  const c = starColors[Math.floor(Math.random() * starColors.length)];
  shootingStars.push({
    x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.5,
    vx: Math.random() * 7 + 5, vy: Math.random() * 3 + 2,
    life: 0, color: `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`
  });
}
const shootingInterval = setInterval(() => { if (Math.random() > 0.4) createShootingStar(); }, 300);

/* End Intro Logic */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
    enableReminderScreen(); // ✅ THIS is correct
  }, 600);
}

const timeout = setTimeout(endIntro, 3500);
/* --- Improved Skip Logic --- */

// 1. Click to Skip
overlay.addEventListener("click", () => {
  clearTimeout(timeout);
  endIntro();
}, { once: true });

// 2. Keypress to Skip (Now targeting the whole window)
window.addEventListener("keydown", (e) => {
  // This ensures the intro ends regardless of which key is pressed
  clearTimeout(timeout);
  endIntro();
}, { once: true });

resizeCanvases();
animate();
  
const dotsElement = document.getElementById('loading-dots');
let dotCount = 0;

const dotInterval = setInterval(() => {
  dotCount = (dotCount + 1) % 4; 
  // Adding a space after the dot inside the repeat function
  if(dotsElement) dotsElement.textContent = ". ".repeat(dotCount);
}, 400);

/* Update your endIntro function to stop the dots too */
/* =============================
   REMINDERS → RULES → START FLOW
============================= */

function enableReminderScreen() {
  const reminderOverlay = document.getElementById("reminder-overlay");
  const reminders = document.getElementById("reminders-content");
  const rules = document.getElementById("rules-content");
  const arrow = document.getElementById("rules-arrow");
  const startBtn = document.getElementById("start-game");

  if (!reminderOverlay || !reminders || !rules || !arrow || !startBtn) return;

  // Show reminders
  reminderOverlay.hidden = false;
  reminderOverlay.style.opacity = "0";
  requestAnimationFrame(() => {
    reminderOverlay.style.transition = "opacity 0.4s ease";
    reminderOverlay.style.opacity = "1";
  });

  // ------------------------
  // STEP 1: Click or key on reminders → show rules
  function showRules() {
    reminders.style.display = "none";
    rules.hidden = false;
    startBtn.hidden = false;
    arrow.style.display = "none";

    // Remove listeners for showing rules
    reminderOverlay.removeEventListener("click", showRules);
    window.removeEventListener("keydown", showRules);

    // Enable closing the rules screen
    enableRulesClose();
  }

  reminderOverlay.addEventListener("click", showRules);
  window.addEventListener("keydown", showRules);

  // Keep arrow clickable as alternative
  arrow.addEventListener("click", (e) => {
    e.stopPropagation();
    showRules();
  });
}

/* ------------------------
   STEP 2: Close overlay from rules
------------------------ */
function closeRules() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  overlay.style.transition = "opacity 0.5s ease";
  overlay.style.opacity = "0";

  // Remove listeners immediately to prevent double triggers
  window.removeEventListener("keydown", closeRules);
  overlay.removeEventListener("click", closeRules);

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove(); showCharacterSelect();
  }, 500);
}

function enableRulesClose() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  // Click anywhere OR any key closes the rules overlay
  overlay.addEventListener("click", closeRules);
  window.addEventListener("keydown", closeRules);

  // Also allow button to close
  document.getElementById("start-game")?.addEventListener("click", closeRules);
}

/* ------------------------
   STEP 3: Call this after intro ends
------------------------ */

/* =============================
   CHARACTER SELECT LOGIC
============================= */
/* =============================
   CHARACTER SELECT LOGIC
============================= */

let selectedCharacter = null;

  // =============================
// LOVE GAME STATE
// =============================
const GameState = {
  land: "darkland",
  category: "physical",
  rungIndex: 0,
  questionIndex: 0,
  correctCount: 0
};

// Each land has ALL letters (not just murk / love)
const LADDERS = {
  darkland: 8,   // D n A L K R A D
  murkland: 8,   // m u r k l a n d
  loveland: 8    // l o v e l a n d
};


function showCharacterSelect() {
  const overlay = document.getElementById("character-overlay");

  // force initial state
  overlay.classList.remove("fade-out");
  overlay.classList.add("visible");
}


const characters = document.querySelectorAll(".character");

characters.forEach(char => {
  char.addEventListener("click", () => {
    const overlay = document.getElementById("character-overlay");

    // Clear previous state
    characters.forEach(c => c.classList.remove("selected", "dimmed"));

    // Select current
    char.classList.add("selected");
    selectedCharacter = char.dataset.character;
    confirmBtn.disabled = false;

    // Dim others
    characters.forEach(c => {
      if (c !== char) c.classList.add("dimmed");
    });

    // Soft fade of screen
    overlay.classList.add("selection-made");
  });
});

// ✅ CONFIRM BUTTON — THIS WAS MISSING
const confirmBtn = document.getElementById("confirm-character");

confirmBtn.addEventListener("click", () => {
  if (!selectedCharacter) return;

  const overlay = document.getElementById("character-overlay");

  overlay.classList.remove("visible");
  overlay.classList.add("fade-out");

  setTimeout(() => {
    overlay.remove();
    startLoveGame();
  }, 800);
});


  // =============================
// CHARACTER MOVEMENT
// =============================
function positionCharacter() {
  const char   = document.getElementById("player-character");
  const img    = document.getElementById("game-background");
  const screen = document.getElementById("game-screen");

  const coords = RUNG_COORDS[GameState.land]; // ✅ land-aware
  const rung = RUNG_COORDS[GameState.land][GameState.rungIndex];

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  char.style.left = `${x}px`;
  char.style.top  = `${y}px`;

  const targetTop = char.offsetTop - screen.clientHeight * 0.65;
  screen.scrollTo({ top: Math.max(0, targetTop), behavior: "smooth" });
}

function moveCharacter(delta) {
  // FALL: Murkland M + wrong/neutral -> Darkland last D
  if (GameState.land === "murkland" && GameState.rungIndex === 0 && delta <= 0) {
    GameState.land = "darkland";
    GameState.rungIndex = LADDERS.darkland - 1; // 7

    const img = document.getElementById("game-background");
    if (img) {
      img.onload = () => positionCharacter();
      img.src = "darkland_screen.png";
    } else {
      positionCharacter();
    }
    return;
  }

  // RETURN: If we are still in EMOTIONAL phase and get a + at Darkland last D, go back to Murkland visuals
  if (
    GameState.land === "darkland" &&
    GameState.rungIndex === LADDERS.darkland - 1 &&
    questionPhase === "emotional" &&
    delta > 0
  ) {
    GameState.land = "murkland";
    GameState.rungIndex = 0;

    const img = document.getElementById("game-background");
    if (img) {
      img.onload = () => positionCharacter();
      img.src = "murkland_screen.png";
    } else {
      positionCharacter();
    }
    return;
  }

  // NORMAL MOVEMENT
  const max = LADDERS[GameState.land] - 1;
  GameState.rungIndex = Math.max(0, Math.min(max, GameState.rungIndex + delta));
  positionCharacter();
}




const subtitles = {
  phoenix: "The Fiery Phoenix . . .",
  kitsune: "The Cunning Kitsune . . .",
  mamiwata: "The Alluring Mami Wata . . .",
  hydra: "The Immortal Hydra . . .",
  human: "The Ruthless Human . . ."
};

const characterImages = {
  phoenix: "1phoenix.png",
  kitsune: "2kitsune.png",
  mamiwata: "3wata.png",
  hydra: "4hydra.png",
  human: "5girl.png"
};

const caption = document.getElementById("character-caption");

// Typewriter function
let typingInterval = null;
function typeWriter(element, text, speed = 50) {
  if (typingInterval) {
    clearInterval(typingInterval);
    typingInterval = null;
  }

  element.textContent = "";
  let i = 0;

  typingInterval = setInterval(() => {
    element.textContent += text.charAt(i);
    i++;

    if (i >= text.length) {
      clearInterval(typingInterval);
      typingInterval = null;
    }
  }, speed);
}


// Character click logic
document.querySelectorAll(".character").forEach(char => {
  char.addEventListener("click", () => {
    const key = char.dataset.character;
    if (!subtitles[key]) return;

    caption.classList.add("visible");
    typeWriter(caption, subtitles[key], 50);
  });
});
 
// =============================
// CARD ENGINE
// =============================

let currentCard = null;
let cardSide = "front";
let cardIndex = 0;
let murkLastSeenIndex = -1; // -1 means none seen yet
let questionPhase = "physical"; // physical → emotional → mental
let lovelandUnlocked = false;



function showQuestionCard(cardData) {
  if (!cardData) {
    console.error("showQuestionCard called with:", cardData);
    return;
  }

  // ✅ Phase detection by ID range
  if (cardData.id >= 100 && cardData.id < 200) questionPhase = "emotional";
  if (cardData.id >= 200 && cardData.id < 300) questionPhase = "mental";

  currentCard = cardData;

  // ✅ Track Murk progress
  const mIdx = MURK_CARDS.findIndex(c => c.id === cardData.id);
  if (mIdx !== -1) murkLastSeenIndex = mIdx;

  cardSide = "front";
  cardMode = "question";

  const layer = document.getElementById("card-layer");
  const card  = document.getElementById("card");
  const front = document.getElementById("card-front");
  const back  = document.getElementById("card-back");

  front.src = cardData.questionFront;
  back.src  = cardData.questionBack;

  card.classList.remove("flipped");
  layer.style.display = "flex";

  scrollToCards();
}



window.addEventListener("keydown", e => {
  if (!currentCard) return;
  if (cardMode !== "question") return;
  if (cardSide !== "back") return;

  const key = e.key.toLowerCase();
  if (!(key in currentCard.outcomes)) return;

  resolveAnswer(key);
});



function resolveAnswer(letter) {
  const delta = currentCard.outcomes[letter];
  showAnswerCard(currentCard, delta);
}

let cardMode = "question"; // "question" | "answer"

const cardEl = document.getElementById("card");
const layer  = document.getElementById("card-layer");

cardEl.addEventListener("click", () => {
  if (!currentCard) return;

  // QUESTION: click flips front -> back only
  if (cardMode === "question") {
    if (cardSide === "front") {
      cardEl.classList.add("flipped");
      cardSide = "back";
    }
    return;
  }

  // ANSWER: click #1 flips front -> back
  if (cardMode === "answer" && cardSide === "front") {
    cardEl.classList.add("flipped");
    cardSide = "back";
    return;
  }

  // ANSWER: click #2 fades + closes + moves
  if (cardMode === "answer" && cardSide === "back") {
    layer.classList.add("fade-out");

    setTimeout(() => {
      layer.classList.remove("fade-out");
      layer.style.display = "none";

      const delta = Number(layer.dataset.delta || 0);

      currentCard = null;
      cardMode = "question";
      cardSide = "front";

      // ✅ were we on FINAL D before moving?
     // ✅ only "pass" final D if you are ON the last D AND the answer moves you UP
// ✅ only "pass" final d of Murkland if you're on top rung AND the answer moves you UP
const wasAtTopMurk =
  GameState.land === "murkland" &&
  GameState.rungIndex === (LADDERS.murkland - 1) &&
  delta > 0;

const passedDarkFinalD =
  !murkTransitionDone &&
  GameState.land === "darkland" &&
  GameState.rungIndex === (LADDERS.darkland - 1) &&
  delta > 0;

// move first
moveCharacter(delta);

// If they just earned a "move up" while already at Murk top,
// go straight to Loveland now (don’t wait for the deck to end).
if (wasAtTopMurk) {
  lovelandUnlocked = true;
  setTimeout(() => transitionToLoveland(), 1200);
  return;
}

// Darkland → Murkland transition (your existing logic)
if (passedDarkFinalD) {
  murkTransitionDone = true;
  setTimeout(() => transitionToMurkland(), 2000);
  return;
}

// Normal flow: next card
setTimeout(() => {
  advanceCard();
}, 2000);
    }, 350);
  }
});

  
function scrollToCards() {
  const screen = document.getElementById("game-screen");
  if (!screen) return;

  // make sure the GAME SCREEN is visible in the page
  screen.scrollIntoView({ behavior: "smooth", block: "center" });
}

function showAnswerCard(cardData, delta) {
  const layer = document.getElementById("card-layer");
  const card  = document.getElementById("card");
  const front = document.getElementById("card-front");
  const back  = document.getElementById("card-back");

  // store movement for later
  layer.dataset.delta = String(delta);

  currentCard = cardData;
  cardMode = "answer";
  cardSide = "front";

  card.classList.remove("flipped");

  front.src = cardData.answerFront;
  back.src  = cardData.answerBack;

  layer.style.display = "flex";
}


function advanceCard() {
  cardIndex++;

  // ✅ PHYSICAL finished -> start EMOTIONAL (Murk) questions (ANYWHERE)
  if (questionPhase === "physical" && cardIndex >= PHYSICAL_CARDS.length) {
    questionPhase = "emotional";
    activeDeck = MURK_CARDS;

    // start from where they left off (if any Murk cards were already seen)
    cardIndex = Math.max(0, murkLastSeenIndex + 1);
  }

  // ✅ EMOTIONAL finished -> start MENTAL questions (ANYWHERE)
  if (questionPhase === "emotional" && cardIndex >= MURK_CARDS.length) {
    questionPhase = "mental";
    activeDeck = MENTAL_CARDS;
    cardIndex = 0;

    // ✅ ONLY show Loveland visuals if unlocked
    if (lovelandUnlocked) {
      transitionToLoveland();
      return;
    }
  }

  if (cardIndex < activeDeck.length) {
    setTimeout(() => {
      showQuestionCard(activeDeck[cardIndex]);
    }, 2000);
  }
}



function transitionToMurkland() {
  // dramatic glow flash
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "murkland";
  GameState.rungIndex = 0;

  // ✅ Murk deck
  activeDeck = MURK_CARDS;
  questionPhase = "emotional";
  // ✅ start Murkland where they left off on emotional questions
  const nextMurkIndex = Math.max(
    0,
    Math.min((typeof murkLastSeenIndex === "number" ? murkLastSeenIndex : -1) + 1, MURK_CARDS.length - 1)
  );
  cardIndex = nextMurkIndex;

  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();

    setTimeout(() => {
      const nextCard = activeDeck[cardIndex];
      if (!nextCard) {
        console.error("No Murk card at index:", cardIndex, "Deck:", activeDeck);
        return;
      }
      showQuestionCard(nextCard);
    }, 1200);
  };

  img.src = "murkland_screen.png";
}
  
function transitionToLoveland() {
  // glow flash (same effect)
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "loveland";
  GameState.rungIndex = 0;

  // ✅ switch to mental deck (Loveland questions)
  activeDeck = MENTAL_CARDS;
  cardIndex = 0;

  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();
    setTimeout(() => {
      showQuestionCard(activeDeck[cardIndex]);
    }, 1200);
  };

  img.src = "loveland_screen.png";
}



// =============================
// START LOVE GAME
// =============================
// =============================
// START LOVE GAME
// =============================
function startLoveGame() {
  const screen = document.getElementById("game-screen");
  screen.hidden = false;
  screen.style.display = "block";

  GameState.land = "darkland";
  GameState.rungIndex = 0;
  questionPhase = "physical";
lovelandUnlocked = false;
activeDeck = getDeckForPhase();
cardIndex = 0;
murkLastSeenIndex = -1;
murkTransitionDone = false;
  const img = document.getElementById("game-background");

  // important: clear previous onload (prevents weirdness on replays)
  img.onload = null;

  img.onload = () => {
    const char = document.getElementById("player-character");
    char.src = characterImages[selectedCharacter];
    positionCharacter();
    showBeginText();
    cardIndex = 0;
  };

  img.src = "darkland_screen.png";
}

function showBeginText() {
  if (beginShown) return;
  beginShown = true;

  const begin = document.getElementById("begin-text");
  const img   = document.getElementById("game-background");

  const rung = RUNG_COORDS.darkland[0]; // bottom D

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  begin.style.left = `${x}px`;
  begin.style.top  = `${y - 180}px`;
  begin.style.opacity = 1;
  begin.textContent = "";

  typeWriter(begin, "BEGIN", 120);

  // BEGIN stays visible, then fades
  setTimeout(() => {
    begin.style.transition = "opacity 0.8s ease";
    begin.style.opacity = 0;

    // ✅ AFTER fade finishes, show first card
    setTimeout(() => {
      cardIndex = 0;
showQuestionCard(activeDeck[0]);
    }, 850);

  }, 2800);
}

// Your coordinates
const RUNG_COORDS = {
  darkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  // TODO: replace these with your real murkland rung positions
  murkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  loveland: [
  { x: 904,  y: 1934 },
  { x: 1057, y: 1654 },
  { x: 969,  y: 1380 },
  { x: 1108, y: 1177 },
  { x: 731,  y: 907  },
  { x: 884,  y: 609  },
  { x: 583,  y: 434  },
  { x: 735,  y: 173  }
]
  
};



</script>
</body>
</html>
