<!DOCTYPE html>
<html lang="en">
<head>
  <title>Love Game</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<canvas id="mouse-canvas"></canvas>

<div class="header">
  <h1>Love Game</h1>
  <p>~ A Quest to Assess your Mental, Physical, and Emotional Health ~</p>
</div>

<div class="navbar">
  <a href="index.html">Play</a>
  <a href="about.html">About</a>
  <a href="#">Community</a>
<!-- <a href="#" class="right">Log In</a> -->
</div>
  
<div id="intro-overlay">
  <canvas id="starfield"></canvas>
  <div id="intro-text" class="cyber-text">ENTERING CYBERSPACE <span id="loading-dots"></span></div>
</div>
<!-- SECOND SCREEN: REMINDERS -->
<div id="reminder-overlay" hidden>
  <div class="reminder-box">

  <!-- REMINDERS (visible first) -->
  <div id="reminders-content">
    <h2>REMINDERS</h2>
    <ol class="reminder-list">
      <li>Be as truthful as possible (to ensure that your final result truly reflects your current health!)</li>
      <li>Play whenever you wish to reassess your wellbeing status . . .</li>
      <li>Should you land in a territory that concerns you, apply balanced Self and External love — and return later.</li>
      <li>Societal factors, including racial bias, socioeconomic barriers, and gender identity, may influence outcomes.</li>
      <li><strong>Ecstasy</strong> — The highest realm where energy and love abound.</li>
      <li><strong>Loveland</strong> — Balance exists, though some Murktivities linger.</li>
      <li><strong>Murkland</strong> — Clouded energy causes fluctuating health.</li>
      <li><strong>Darkland</strong> — A pit where murk compounds into darkness.</li>
    </ol>
  </div>

  <!-- Arrow -->
  <div id="rules-arrow" aria-label="Show rules">➜</div>

  <!-- RULES (hidden initially) -->
  <div id="rules-content" hidden>
    <h2>RULES</h2>
    <ol class="reminder-list">
      <li>Click the card presented and answer its question.</li>
      <li>If you answer in a way that shows balanced Self and External love, your character will move up.</li>
      <li>If you answer in a way that shows an imbalance of Self and External love, your character will move down.</li>
      <li>Enough balanced answers will move your character into <strong>Loveland</strong>, and eventually, <strong>Ecstasy</strong> (without narcotics!).</li>
      <li>Enough imbalanced answers will move your character into <strong>Murkland</strong>, and eventually, <strong>Darkland</strong>.</li>
    </ol>
  </div>

  <!-- BUTTON (hidden initially) -->
  <button id="start-game" hidden>FOR SURE :)</button>

</div>

</div>

<!-- CHARACTER SELECT SCREEN -->
<div id="character-overlay" class="hidden">
  <div id="character-caption" class="hidden"></div>
  <h2 class="character-title">CHOOSE YOUR CHARACTER!</h2>

  <div class="character-grid">
    <img src="1phoenix.png" class="character" data-character="phoenix">
    <img src="2kitsune.png" class="character" data-character="kitsune">
    <img src="3wata.png" class="character" data-character="mamiwata">
    <img src="4hydra.png" class="character" data-character="hydra">
    <img src="5girl.png" class="character" data-character="human">

  </div>

  <button id="confirm-character" disabled>CONFIRM</button>
</div>

<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="side-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.03 0.15" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
    <filter id="top-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.15 0.03" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
  </defs>
</svg>

 <div id="game-screen" hidden>
    <div id="card-layer">
  <div id="card" class="card">
    <img id="card-front">
    <img id="card-back">
  </div>
</div>
  <div id="board">
    <div id="ladder-wrapper">
      <img id="game-background" />
      <img id="player-character" />
      <div id="begin-text" class="begin-text"></div>
    </div>
  </div>

  <div id="card-container"></div>
</div>
  
<script>
// =============================
// DAILY PLAY LIMIT
// =============================
 /* const todayKey = new Date().toDateString();

if (localStorage.getItem("lovegame-played") === todayKey) {
  document.body.innerHTML = `
    <div class="cyber-text" style="text-align:center; margin-top:40vh;">
      Come back tomorrow, fellow traveler . . .
    </div>
  `;
  throw new Error("Daily limit reached");
}

localStorage.setItem("lovegame-played", todayKey); --- */


let beginShown = false;

// =============================
// CARD DATA (QUESTIONS + ANSWERS)
// =============================

const PHYSICAL_CARDS = [
  {
    id: 1,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q1_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a1_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c:  0,
      d: +1,
      e: +1
    }
  },

  {
    id: 2,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q2_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a2_back.png",

    outcomes: {
      a: -1,
      b: -1,
      c: -1,
      d: +1,
      e: +1
    }
  },
  
{
    id: 3,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q3_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a3_back.png",

    outcomes: {
      a: 0,
      b: -1,
      c: +1,
      d: +1
    }
  },

{
    id: 4,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q4_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a4_back.png",

    outcomes: {
      a: +1,
      b: +1,
      c: -1,
      d: 0
    }
  },
  
  {
    id: 5,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q5_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a5_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: +1
    }
  },

  {
    id: 6,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q6_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a6_back.png",

    outcomes: {
      a: +1,
      b: 0,
      c: -1,
      d: +1
    }
  },

  {
    id: 7,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q7_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a7_back.png",

    outcomes: {
      a: 0,
      b: +1,
      c: -1,
      d: -1
    }
  },

  {
    id: 8,
    questionFront: "cards_physical_q1_front.png",
    questionBack:  "cards_physical_q8_back.png",
    answerFront:   "cards_physical_a1_front.png",
    answerBack:    "cards_physical_a8_back.png",

    outcomes: {
      a: +1,
      b: -1,
      c: 0,
      d: -1
    }
  }
  // add up to 8
];

// -----------------------------
// MURKLAND CARDS (make your own)
// -----------------------------
const MURK_CARDS = [
  {
    id: 101,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q1_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a1_back.png",
    outcomes: { 
      a:-1, b:0, c:+1
    }
  },
  
{
    id: 102,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q2_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a2_back.png",
    outcomes: { 
      a:+1, b:0, c:+1, d:-1, e:-1
    }
  },

{
    id: 103,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q3_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a3_back.png",
    outcomes: { 
      a:-1, b:-1, c:+1, d:0, e:+1
    }
  },

  {
    id: 104,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q4_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a4_back.png",
    outcomes: { 
      a:+1, b:+1, c:+1, d:-1
    }
  },

    {
    id: 105,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q5_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a5_back.png",
    outcomes: { 
      a:-1, b:0, c:0, d:+1
    }
  },

  {
    id: 106,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q6_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a6_back.png",
    outcomes: { 
      a:+1, b:+1, c:0, d:-1
    }
  },

  {
    id: 107,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q7_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a7_back.png",
    outcomes: { 
      a:0, b:+1, c:-1, d:+1, e:-1
    }
  },
  
{
    id: 108,
    questionFront: "murk_q1_front.png",
    questionBack:  "murk_q8_back.png",
    answerFront:   "murk_a1_front.png",
    answerBack:    "murk_a8_back.png",
    outcomes: { 
      a:+1, b:0, c:-1, d:+1
    }
  },
  
  // add more...
];

// -----------------------------
// LOVELAND CARDS (MENTAL)
// -----------------------------
const MENTAL_CARDS = [
  {
    id: 201,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q1_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a1_back.png",
    outcomes: { a:-1, b:+1, c:0, d:-1 }
  },
  
  {
    id: 202,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q2_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a2_back.png",
    outcomes: { a:-1, b:0, c:+1, d:-1 }
  },

  {
    id: 203,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q3_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a3_back.png",
    outcomes: { a:0, b:+1, c:0, d:-1 }
  },

  {
    id: 204,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q4_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a4_back.png",
    outcomes: { a:-1, b:+1, c:0, d:-1 }
  },

  {
    id: 205,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q5_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a5_back.png",
    outcomes: { a:-1, b:-1, c:0, d:+1, e:-1}
  },

  {
    id: 206,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q6_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a6_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:+1, e:0}
  },

  {
    id: 207,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q7_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a7_back.png",
    outcomes: { a:+1, b:0, c:+1, d:-1}
  },

  {
    id: 208,
    questionFront: "mental_q1_front.png",
    questionBack:  "mental_q8_back.png",
    answerFront:   "mental_a1_front.png",
    answerBack:    "mental_a8_back.png",
    outcomes: { a:-1, b:-1, c:+1, d:0, e:0}
  }
  // add more...
];

// -----------------------------
// ECSTASY BONUS CARD (SPECIAL)
// -----------------------------
const ECSTASY_CARD = {
  id: 301,
  questionFront: "ecstasy_q_front.png",
  questionBack:  "ecstasy_q_back.png",
  answerFront:   "ecstasy_a_front.png",
  answerBack:    "ecstasy_a_back.png",
  outcomes: { a: 0, b: -1, c: +1, d: +1 } // edit letters/outcomes to match your design
};

  
function getDeckForPhase() {
  if (questionPhase === "physical") return PHYSICAL_CARDS;
  if (questionPhase === "emotional") return MURK_CARDS;
  if (questionPhase === "mental") return MENTAL_CARDS;
  return PHYSICAL_CARDS;
}


  
function getActiveDeck() {
  // Murkland screen uses Murk-only
  if (GameState.land === "murkland") return MURK_CARDS;

  // Darkland screen can still ask emotional (Murk) questions,
  // BUT we do NOT show Murkland visuals yet.
  if (GameState.land === "darkland") return [...PHYSICAL_CARDS, ...MURK_CARDS];

  return PHYSICAL_CARDS; // fallback
}


// -----------------------------
// ACTIVE DECK + TRANSITION FLAG
// -----------------------------
let activeDeck = PHYSICAL_CARDS;
let murkTransitionDone = false;

  
/* --- UNIVERSAL MOUSE STREAK SETUP --- */
const mCanvas = document.getElementById("mouse-canvas");
const mCtx = mCanvas.getContext("2d");
let mPoints = [];
const TRAIL_LIFESPAN = 12; // Shortened slightly to reduce lag

function resizeCanvases() {
  mCanvas.width = canvas.width = window.innerWidth;
  mCanvas.height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvases);

window.addEventListener("mousemove", (e) => {
  mPoints.push({ x: e.clientX, y: e.clientY, age: 0 });
});

/* --- INTRO STARFIELD SETUP --- */
const starColors = [[255, 255, 255], [200, 220, 255], [220, 200, 255], [255, 230, 180], [180, 255, 240]];
const overlay = document.getElementById("intro-overlay");
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");

let stars = [];
let shootingStars = []; 
let fireEmbers = [];    
let running = true;

/* Initialize Stars */
function createStars(count = 120) { // Slightly fewer stars for better performance
  stars = [];
  for (let i = 0; i < count; i++) {
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    stars.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: Math.random() * 1.4 + 0.3,
      speed: Math.random() * 0.12 + 0.05,
      color
    });
  }
}
createStars();

/* --- THE OPTIMIZED MERGED LOOP --- */
function animate() {
  // Clear both canvases
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  if (running) ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Draw Mouse Streak First (Optimization: Only one shadow call)
  if (mPoints.length > 1) {
    mCtx.shadowBlur = 8; // Lower value = faster performance
    mCtx.shadowColor = "#f5ff3a";
    mCtx.lineCap = "round";
    mCtx.lineJoin = "round";

    for (let i = 1; i < mPoints.length; i++) {
      const p1 = mPoints[i - 1];
      const p2 = mPoints[i];
      const opacity = 1 - (p1.age / TRAIL_LIFESPAN);
      
      mCtx.strokeStyle = `rgba(245, 255, 58, ${opacity})`; 
      mCtx.lineWidth = opacity * 5;
      
      mCtx.beginPath();
      mCtx.moveTo(p1.x, p1.y);
      mCtx.lineTo(p2.x, p2.y);
      mCtx.stroke();
      p1.age++;
    }
    mCtx.shadowBlur = 0; // Turn it off immediately for other elements
  }
  mPoints = mPoints.filter(p => p.age < TRAIL_LIFESPAN);

  // 2. Draw Intro Elements Only If Running
  if (running) {
    /* Background Stars */
    stars.forEach(star => {
      star.y += star.speed;
      if (star.y > canvas.height) star.y = 0;
      ctx.fillStyle = `rgba(${star.color[0]}, ${star.color[1]}, ${star.color[2]}, 0.8)`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    });

    /* Background Shooting Stars (White) */
    shootingStars.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) shootingStars.splice(i, 1);
    });

    /* Border Embers (Orange) */
    fireEmbers.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = "#ff8c00";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) fireEmbers.splice(i, 1);
    });

    /* Spawn Logic */
    if (Math.random() > 0.85) spawnEmbers();
  }

  requestAnimationFrame(animate);
}

function spawnEmbers() {
  const side = Math.floor(Math.random() * 4);
  let ex, ey, evx, evy;
  if (side === 0) { ex = Math.random()*canvas.width; ey = 0; evx = (Math.random()-0.5)*2; evy = Math.random()*4; } 
  else if (side === 1) { ex = Math.random()*canvas.width; ey = canvas.height; evx = (Math.random()-0.5)*2; evy = -Math.random()*4; } 
  else if (side === 2) { ex = 0; ey = Math.random()*canvas.height; evx = Math.random()*4; evy = (Math.random()-0.5)*2; } 
  else { ex = canvas.width; ey = Math.random()*canvas.height; evx = -Math.random()*4; evy = (Math.random()-0.5)*2; }
  fireEmbers.push({ x: ex, y: ey, vx: evx, vy: evy, life: 0 });
}

// Shooting star interval logic
function createShootingStar() {
  const c = starColors[Math.floor(Math.random() * starColors.length)];
  shootingStars.push({
    x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.5,
    vx: Math.random() * 7 + 5, vy: Math.random() * 3 + 2,
    life: 0, color: `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`
  });
}
const shootingInterval = setInterval(() => { if (Math.random() > 0.4) createShootingStar(); }, 300);

/* End Intro Logic */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
    enableReminderScreen(); // ✅ THIS is correct
  }, 600);
}

const timeout = setTimeout(endIntro, 3500);
/* --- Improved Skip Logic --- */

// 1. Click to Skip
overlay.addEventListener("click", () => {
  clearTimeout(timeout);
  endIntro();
}, { once: true });

// 2. Keypress to Skip (Now targeting the whole window)
window.addEventListener("keydown", (e) => {
  // This ensures the intro ends regardless of which key is pressed
  clearTimeout(timeout);
  endIntro();
}, { once: true });

resizeCanvases();
animate();
  
const dotsElement = document.getElementById('loading-dots');
let dotCount = 0;

const dotInterval = setInterval(() => {
  dotCount = (dotCount + 1) % 4; 
  // Adding a space after the dot inside the repeat function
  if(dotsElement) dotsElement.textContent = ". ".repeat(dotCount);
}, 400);

/* Update your endIntro function to stop the dots too */
/* =============================
   REMINDERS → RULES → START FLOW
============================= */

function enableReminderScreen() {
  const reminderOverlay = document.getElementById("reminder-overlay");
  const reminders = document.getElementById("reminders-content");
  const rules = document.getElementById("rules-content");
  const arrow = document.getElementById("rules-arrow");
  const startBtn = document.getElementById("start-game");

  if (!reminderOverlay || !reminders || !rules || !arrow || !startBtn) return;

  // Show reminders
  reminderOverlay.hidden = false;
  reminderOverlay.style.opacity = "0";
  requestAnimationFrame(() => {
    reminderOverlay.style.transition = "opacity 0.4s ease";
    reminderOverlay.style.opacity = "1";
  });

  // ------------------------
  // STEP 1: Click or key on reminders → show rules
  function showRules() {
    reminders.style.display = "none";
    rules.hidden = false;
    startBtn.hidden = false;
    arrow.style.display = "none";

    // Remove listeners for showing rules
    reminderOverlay.removeEventListener("click", showRules);
    window.removeEventListener("keydown", showRules);

    // Enable closing the rules screen
    enableRulesClose();
  }

  reminderOverlay.addEventListener("click", showRules);
  window.addEventListener("keydown", showRules);

  // Keep arrow clickable as alternative
  arrow.addEventListener("click", (e) => {
    e.stopPropagation();
    showRules();
  });
}

/* ------------------------
   STEP 2: Close overlay from rules
------------------------ */
function closeRules() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  overlay.style.transition = "opacity 0.5s ease";
  overlay.style.opacity = "0";

  // Remove listeners immediately to prevent double triggers
  window.removeEventListener("keydown", closeRules);
  overlay.removeEventListener("click", closeRules);

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove(); showCharacterSelect();
  }, 500);
}

function enableRulesClose() {
  const overlay = document.getElementById("reminder-overlay");
  if (!overlay) return;

  // Click anywhere OR any key closes the rules overlay
  overlay.addEventListener("click", closeRules);
  window.addEventListener("keydown", closeRules);

  // Also allow button to close
  document.getElementById("start-game")?.addEventListener("click", closeRules);
}

/* ------------------------
   STEP 3: Call this after intro ends
------------------------ */

/* =============================
   CHARACTER SELECT LOGIC
============================= */
/* =============================
   CHARACTER SELECT LOGIC
============================= */

let selectedCharacter = null;

  // =============================
// LOVE GAME STATE
// =============================
const GameState = {
  land: "darkland",
  category: "physical",
  rungIndex: 0,
  questionIndex: 0,
  correctCount: 0
};

// Each land has ALL letters (not just murk / love)
const LADDERS = {
  darkland: 8,   // D n A L K R A D
  murkland: 8,   // m u r k l a n d
  loveland: 8    // l o v e l a n d
};


function showCharacterSelect() {
  const overlay = document.getElementById("character-overlay");

  // force initial state
  overlay.classList.remove("fade-out");
  overlay.classList.add("visible");
}


const characters = document.querySelectorAll(".character");

characters.forEach(char => {
  char.addEventListener("click", () => {
    const overlay = document.getElementById("character-overlay");

    // Clear previous state
    characters.forEach(c => c.classList.remove("selected", "dimmed"));

    // Select current
    char.classList.add("selected");
    selectedCharacter = char.dataset.character;
    confirmBtn.disabled = false;

    // Dim others
    characters.forEach(c => {
      if (c !== char) c.classList.add("dimmed");
    });

    // Soft fade of screen
    overlay.classList.add("selection-made");
  });
});

// ✅ CONFIRM BUTTON — THIS WAS MISSING
const confirmBtn = document.getElementById("confirm-character");

confirmBtn.addEventListener("click", () => {
  if (!selectedCharacter) return;

  const overlay = document.getElementById("character-overlay");

  overlay.classList.remove("visible");
  overlay.classList.add("fade-out");

  setTimeout(() => {
    overlay.remove();
    startLoveGame();
  }, 800);
});


  // =============================
// CHARACTER MOVEMENT
// =============================
function positionCharacter() {
  const char   = document.getElementById("player-character");
  const img    = document.getElementById("game-background");
  const screen = document.getElementById("game-screen");

  const coords = RUNG_COORDS[GameState.land]; // ✅ land-aware
  const rung = RUNG_COORDS[GameState.land][GameState.rungIndex];

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  char.style.left = `${x}px`;
  char.style.top  = `${y}px`;

  const targetTop = char.offsetTop - screen.clientHeight * 0.65;
  screen.scrollTo({ top: Math.max(0, targetTop), behavior: "smooth" });
}

function bigGlowTransition(doDuringGlow, doAfterGlow = null) {
  const glow = document.createElement("div");
  glow.style.position = "fixed";
  glow.style.inset = "0";
  glow.style.zIndex = "9999999";
  glow.style.pointerEvents = "none";

  // ✅ Bigger glow: larger radius + stronger spread
  glow.style.background = `
    radial-gradient(circle at center,
      rgba(245,255,58,0.95) 0%,
      rgba(245,255,58,0.55) 25%,
      rgba(245,255,58,0.25) 50%,
      rgba(0,0,0,0) 78%
    )
  `;
  glow.style.opacity = "0";
  glow.style.transition = "opacity 0.45s ease";
  glow.style.filter = "blur(1px)"; // subtle “wrap” feel

  document.body.appendChild(glow);

  // fade IN
  requestAnimationFrame(() => {
    glow.style.opacity = "1";
  });

  // run the work while glow is fully visible
  setTimeout(() => {
    try { doDuringGlow?.(); } catch (e) { console.error(e); }

    // fade OUT after the new screen is in place
    setTimeout(() => {
      glow.style.transition = "opacity 0.65s ease";
      glow.style.opacity = "0";
      setTimeout(() => {
        glow.remove();
        doAfterGlow?.();
      }, 700);
    }, 350);
  }, 250);
}

  
function moveCharacter(delta) {

  const img = document.getElementById("game-background");

  const continueWithNextCard = () => {
    positionCharacter();
    setTimeout(() => {
      advanceCard();
    }, 450);
  };

  /* =====================
     MURKLAND → DARKLAND
  ===================== */
  if (GameState.land === "murkland" && GameState.rungIndex === 0 && delta <= 0) {
  GameState.land = "darkland";
  GameState.rungIndex = LADDERS.darkland - 1;

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) return;

    img.onload = () => {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
    };

    img.src = "darkland_screen.png";
  });

  return true;
}

  /* =====================
     DARKLAND → MURKLAND
  ===================== */
  if (
  GameState.land === "darkland" &&
  GameState.rungIndex === LADDERS.darkland - 1 &&
  questionPhase === "emotional" &&
  delta > 0
) {
  GameState.land = "murkland";
  GameState.rungIndex = 0;

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) return;

    img.onload = () => {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
    };

    img.src = "murkland_screen.png";
  });

  return true;
}


  /* =====================
     LOVELAND → MURKLAND
  ===================== */
 /* =====================
   LOVELAND → MURKLAND (visual drop only; KEEP current deck)
===================== */
if (GameState.land === "loveland" && GameState.rungIndex === 0 && delta < 0) {
  GameState.land = "murkland";
  GameState.rungIndex = LADDERS.murkland - 1;

  // ✅ DO NOT change questionPhase / activeDeck here.

  const img = document.getElementById("game-background");

  bigGlowTransition(() => {
    if (!img) {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
      return;
    }

    img.onload = () => {
      positionCharacter();
      setTimeout(() => advanceCard(), 450);
    };

    img.src = "murkland_screen.png";
  });

  return true;
}



  /* =====================
     NORMAL MOVEMENT
  ===================== */
  const max = LADDERS[GameState.land] - 1;
  GameState.rungIndex = Math.max(0, Math.min(max, GameState.rungIndex + delta));
  positionCharacter();
  return false;
}
  




const subtitles = {
  phoenix: "The Fiery Phoenix . . .",
  kitsune: "The Cunning Kitsune . . .",
  mamiwata: "The Alluring Mami Wata . . .",
  hydra: "The Immortal Hydra . . .",
  human: "The Ruthless Human . . ."
};

const characterImages = {
  phoenix: "1phoenix.png",
  kitsune: "2kitsune.png",
  mamiwata: "3wata.png",
  hydra: "4hydra.png",
  human: "5girl.png"
};

const caption = document.getElementById("character-caption");

// Typewriter function
let typingInterval = null;
function typeWriter(element, text, speed = 50) {
  if (typingInterval) {
    clearInterval(typingInterval);
    typingInterval = null;
  }

  element.textContent = "";
  let i = 0;

  typingInterval = setInterval(() => {
    element.textContent += text.charAt(i);
    i++;

    if (i >= text.length) {
      clearInterval(typingInterval);
      typingInterval = null;
    }
  }, speed);
}


// Character click logic
document.querySelectorAll(".character").forEach(char => {
  char.addEventListener("click", () => {
    const key = char.dataset.character;
    if (!subtitles[key]) return;

    caption.classList.add("visible");
    typeWriter(caption, subtitles[key], 50);
  });
});
 
// =============================
// CARD ENGINE
// =============================

let currentCard = null;
let cardSide = "front";
let cardIndex = 0;
let murkLastSeenIndex = -1; // -1 means none seen yet
let questionPhase = "physical"; // physical → emotional → mental
let lovelandUnlocked = false;
let mentalLastSeenIndex = -1;



function showQuestionCard(cardData) {
  if (!cardData) {
    console.error("showQuestionCard called with:", cardData);
    return;
  }

  // ✅ Phase detection by ID range
  if (cardData.id >= 100 && cardData.id < 200) questionPhase = "emotional";
  if (cardData.id >= 200 && cardData.id < 300) questionPhase = "mental";

  currentCard = cardData;

  // ✅ Track Murk progress
  const mIdx = MURK_CARDS.findIndex(c => c.id === cardData.id);
  if (mIdx !== -1) murkLastSeenIndex = mIdx;
  // ✅ Track Mental progress
const tIdx = MENTAL_CARDS.findIndex(c => c.id === cardData.id);
if (tIdx !== -1) mentalLastSeenIndex = tIdx;

  cardSide = "front";
  cardMode = "question";

  const layer = document.getElementById("card-layer");
  const card  = document.getElementById("card");
  const front = document.getElementById("card-front");
  const back  = document.getElementById("card-back");

  front.src = cardData.questionFront;
  back.src  = cardData.questionBack;

  card.classList.remove("flipped");
  layer.style.display = "flex";

  scrollToCards();
}



window.addEventListener("keydown", e => {
  if (!currentCard) return;
  if (cardMode !== "question") return;
  if (cardSide !== "back") return;

  const key = e.key.toLowerCase();
  if (!(key in currentCard.outcomes)) return;

  resolveAnswer(key);
});



function resolveAnswer(letter) {
  const delta = currentCard.outcomes[letter];
  showAnswerCard(currentCard, delta);
}

let cardMode = "question"; // "question" | "answer"

const cardEl = document.getElementById("card");
const layer  = document.getElementById("card-layer");

cardEl.addEventListener("click", () => {
  if (!currentCard) return;

  // QUESTION: click flips front -> back only
  if (cardMode === "question") {
    if (cardSide === "front") {
      cardEl.classList.add("flipped");
      cardSide = "back";
    }
    return;
  }

  // ANSWER: click #1 flips front -> back
  if (cardMode === "answer" && cardSide === "front") {
    cardEl.classList.add("flipped");
    cardSide = "back";
    return;
  }

  // ANSWER: click #2 fades + closes + moves
  if (cardMode === "answer" && cardSide === "back") {
    layer.classList.add("fade-out");

    setTimeout(() => {
      layer.classList.remove("fade-out");
      layer.style.display = "none";

      const delta = Number(layer.dataset.delta || 0);
      const answeredCardId = Number(layer.dataset.cardId || 0);
      currentCard = null;
      cardMode = "question";
      cardSide = "front";
      // ✅ ECSTASY bonus resolution
if (answeredCardId === ECSTASY_CARD.id) {
  if (delta > 0) {
    transitionToEcstasy();
    setTimeout(() => showJourneyEnd("ecstasy"), 2000);
  } else {
    // stay Loveland
    GameState.land = "loveland";
    setTimeout(() => showJourneyEnd("loveland"), 800);
  }
  return;
}

      // ✅ were we on FINAL D before moving?
     // ✅ only "pass" final D if you are ON the last D AND the answer moves you UP
// ✅ only "pass" final d of Murkland if you're on top rung AND the answer moves you UP
const wasAtTopMurk =
  GameState.land === "murkland" &&
  GameState.rungIndex === (LADDERS.murkland - 1) &&
  delta > 0;

const passedDarkFinalD =
  !murkTransitionDone &&
  GameState.land === "darkland" &&
  GameState.rungIndex === (LADDERS.darkland - 1) &&
  delta > 0;

// move first
const transitioned = moveCharacter(delta);
if (transitioned) return;

// If they just earned a "move up" while already at Murk top,
// go straight to Loveland now (don’t wait for the deck to end).
if (wasAtTopMurk) {
  lovelandUnlocked = true;
  setTimeout(() => transitionToLoveland(), 1200);
  return;
}

// Darkland → Murkland transition (your existing logic)
if (passedDarkFinalD) {
  murkTransitionDone = true;
  setTimeout(() => transitionToMurkland(), 2000);
  return;
}

// Normal flow: next card
setTimeout(() => {
  advanceCard();
}, 2000);
    }, 350);
  }
});

  
function scrollToCards() {
  const screen = document.getElementById("game-screen");
  if (!screen) return;

  // make sure the GAME SCREEN is visible in the page
  screen.scrollIntoView({ behavior: "smooth", block: "center" });
}

function showAnswerCard(cardData, delta) {
  const layer = document.getElementById("card-layer");
  const card  = document.getElementById("card");
  const front = document.getElementById("card-front");
  const back  = document.getElementById("card-back");

  layer.dataset.delta = String(delta);
  layer.dataset.cardId = String(cardData.id); // ✅ add this

  currentCard = cardData;
  cardMode = "answer";
  cardSide = "front";

  card.classList.remove("flipped");

  front.src = cardData.answerFront;
  back.src  = cardData.answerBack;

  layer.style.display = "flex";
}



function advanceCard() {
  cardIndex++;
  // ✅ END: after last mental card
if (questionPhase === "mental" && cardIndex >= MENTAL_CARDS.length) {
  const onTopLoveland =
    GameState.land === "loveland" &&
    GameState.rungIndex === (LADDERS.loveland - 1);

  if (onTopLoveland) {
    // show ONE bonus ecstasy card
    questionPhase = "ecstasy";
    activeDeck = [ECSTASY_CARD];
    cardIndex = 0;

    setTimeout(() => showQuestionCard(ECSTASY_CARD), 700);
  } else {
    // otherwise just show final land
    setTimeout(() => showJourneyEnd(GameState.land), 700);
  }
  return;
}
    // ✅ If we are in ecstasy bonus phase, don't auto-advance past the single card
  if (questionPhase === "ecstasy") return;

  // ✅ PHYSICAL finished -> start EMOTIONAL (Murk) questions (ANYWHERE)
  if (questionPhase === "physical" && cardIndex >= PHYSICAL_CARDS.length) {
    questionPhase = "emotional";
    activeDeck = MURK_CARDS;

    // start from where they left off (if any Murk cards were already seen)
    cardIndex = Math.max(0, murkLastSeenIndex + 1);
  }

  // ✅ EMOTIONAL finished -> start MENTAL questions (ANYWHERE)
  if (questionPhase === "emotional" && cardIndex >= MURK_CARDS.length) {
    questionPhase = "mental";
    activeDeck = MENTAL_CARDS;
// resume from where they left off
const nextMentalIndex = Math.max(
  0,
  Math.min((typeof mentalLastSeenIndex === "number" ? mentalLastSeenIndex : -1) + 1, MENTAL_CARDS.length - 1)
);
cardIndex = nextMentalIndex;


    // ✅ ONLY show Loveland visuals if unlocked
    if (lovelandUnlocked) {
      transitionToLoveland();
      return;
    }
  }

  if (cardIndex < activeDeck.length) {
    setTimeout(() => {
      showQuestionCard(activeDeck[cardIndex]);
    }, 2000);
  }
}



function transitionToMurkland() {
  // dramatic glow flash
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "murkland";
  GameState.rungIndex = 0;

  // ✅ Murk deck
  activeDeck = MURK_CARDS;
  questionPhase = "emotional";
  // ✅ start Murkland where they left off on emotional questions
  const nextMurkIndex = Math.max(
    0,
    Math.min((typeof murkLastSeenIndex === "number" ? murkLastSeenIndex : -1) + 1, MURK_CARDS.length - 1)
  );
  cardIndex = nextMurkIndex;

  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();

    setTimeout(() => {
      const nextCard = activeDeck[cardIndex];
      if (!nextCard) {
        console.error("No Murk card at index:", cardIndex, "Deck:", activeDeck);
        return;
      }
      showQuestionCard(nextCard);
    }, 1200);
  };

  img.src = "murkland_screen.png";
}
  
function transitionToLoveland() {
  // glow flash (same effect)
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  // swap land + reset position
  GameState.land = "loveland";
  GameState.rungIndex = 0;

  // ✅ switch to mental deck (Loveland questions)
  // ✅ switch to mental deck (Loveland questions) — RESUME
activeDeck = MENTAL_CARDS;

const nextMentalIndex = Math.max(
  0,
  Math.min((typeof mentalLastSeenIndex === "number" ? mentalLastSeenIndex : -1) + 1, MENTAL_CARDS.length - 1)
);
cardIndex = nextMentalIndex;


  const img = document.getElementById("game-background");
  if (!img) return;

  img.onload = () => {
    positionCharacter();
    setTimeout(() => {
      showQuestionCard(activeDeck[cardIndex]);
    }, 1200);
  };

  img.src = "loveland_screen.png";
}

function landLabel(land) {
  const map = {
    darkland: "Darkland",
    murkland: "Murkland",
    loveland: "Loveland",
    ecstasy: "Ecstasy"
  };
  return map[land] || "Loveland";
}

function showJourneyEnd(finalLand) {
  // hide cards
  const layer = document.getElementById("card-layer");
  if (layer) layer.style.display = "none";

  // fade the game screen
  const screen = document.getElementById("game-screen");
  if (screen) {
    screen.style.transition = "opacity 0.9s ease";
    screen.style.opacity = "0";
  }

  // glow overlay
  const end = document.createElement("div");
end.id = "journey-end-overlay";
  end.style.position = "fixed";
  end.style.inset = "0";
  end.style.zIndex = "9999999";
  end.style.display = "flex";
  end.style.alignItems = "center";
  end.style.justifyContent = "center";
  end.style.background = "rgba(0,0,0,0.78)";
  end.style.opacity = "0";
  end.style.transition = "opacity 1.0s ease";

  const msg = document.createElement("div");
  msg.style.fontFamily = "Georgia, 'Times New Roman', serif";
  msg.style.textTransform = "uppercase";
  msg.style.letterSpacing = "2px";
  msg.style.fontSize = "clamp(20px, 3vw, 44px)";
  msg.style.textAlign = "center";
  msg.style.color = "#f5ff3a";
  msg.style.textShadow = "0 0 16px rgba(245,255,58,0.95), 0 0 44px rgba(245,255,58,0.35)";
  msg.style.padding = "24px";
  msg.textContent = `Your journey has brought you to ${landLabel(finalLand)}.`;

  end.appendChild(msg);
  document.body.appendChild(end);

  requestAnimationFrame(() => {
    end.style.opacity = "1";
  });
}

function transitionToEcstasy() {
  // glow flash
  const flash = document.createElement("div");
  flash.style.position = "fixed";
  flash.style.inset = "0";
  flash.style.zIndex = "999999";
  flash.style.pointerEvents = "none";
  flash.style.background =
    "radial-gradient(circle at center, rgba(245,255,58,0.85), rgba(0,0,0,0) 60%)";
  flash.style.opacity = "0";
  flash.style.transition = "opacity 0.35s ease";
  document.body.appendChild(flash);

  requestAnimationFrame(() => (flash.style.opacity = "1"));
  setTimeout(() => {
    flash.style.opacity = "0";
    setTimeout(() => flash.remove(), 450);
  }, 450);

  GameState.land = "ecstasy";

  const char = document.getElementById("player-character");
  if (char) char.style.display = "none";

  const img = document.getElementById("game-background");
  if (!img) return;
  img.onload = () => {};
  img.src = "ecstasy_screen.png"; // <-- your file
}


// =============================
// START LOVE GAME
// =============================
// =============================
// START LOVE GAME
// =============================
function startLoveGame() {
  const screen = document.getElementById("game-screen");
  screen.hidden = false;
  screen.style.display = "block";
  // ✅ reset from end-screen fade
  screen.style.opacity = "1";
  screen.style.transition = "none";
  requestAnimationFrame(() => {
    screen.style.transition = ""; // restore normal transitions later if you want
  });

  // ✅ remove any previous journey overlay if it exists
  document.getElementById("journey-end-overlay")?.remove();

  // ✅ make sure character is visible again (ecstasy hides it)
  const char = document.getElementById("player-character");
  if (char) char.style.display = "block";

  GameState.land = "darkland";
  GameState.rungIndex = 0;
  questionPhase = "physical";
lovelandUnlocked = false;
activeDeck = getDeckForPhase();
cardIndex = 0;
murkLastSeenIndex = -1;
mentalLastSeenIndex = -1;
murkTransitionDone = false;
  const img = document.getElementById("game-background");

  // important: clear previous onload (prevents weirdness on replays)
  img.onload = null;
  beginShown = false;
  img.onload = () => {
    const char = document.getElementById("player-character");
    char.src = characterImages[selectedCharacter];
    positionCharacter();
    showBeginText();
    cardIndex = 0;
  };

  img.src = "darkland_screen.png";
}

function showBeginText() {
  if (beginShown) return;
  beginShown = true;

  const begin = document.getElementById("begin-text");
  const img   = document.getElementById("game-background");

  const rung = RUNG_COORDS.darkland[0]; // bottom D

  const x = (rung.x / 1545) * img.clientWidth;
  const y = (rung.y / 2000) * img.clientHeight;

  begin.style.left = `${x}px`;
  begin.style.top  = `${y - 180}px`;
  begin.style.opacity = 1;
  begin.textContent = "";

  typeWriter(begin, "BEGIN", 120);

  // BEGIN stays visible, then fades
  setTimeout(() => {
    begin.style.transition = "opacity 0.8s ease";
    begin.style.opacity = 0;

    // ✅ AFTER fade finishes, show first card
    setTimeout(() => {
      cardIndex = 0;
showQuestionCard(activeDeck[0]);
    }, 850);

  }, 2800);
}

// Your coordinates
const RUNG_COORDS = {
  darkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  // TODO: replace these with your real murkland rung positions
  murkland: [
    { x: 904,  y: 1934 },
    { x: 1057, y: 1654 },
    { x: 969,  y: 1380 },
    { x: 1108, y: 1177 },
    { x: 731,  y: 907  },
    { x: 884,  y: 609  },
    { x: 583,  y: 434  },
    { x: 735,  y: 173  }
  ],

  loveland: [
  { x: 904,  y: 1934 },
  { x: 1057, y: 1654 },
  { x: 969,  y: 1380 },
  { x: 1108, y: 1177 },
  { x: 731,  y: 907  },
  { x: 884,  y: 609  },
  { x: 583,  y: 434  },
  { x: 735,  y: 173  }
]
  
};



</script>
</body>
</html>
