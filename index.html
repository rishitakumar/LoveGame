<!DOCTYPE html>
<html lang="en">
<head>
  <title>Love Game</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<canvas id="mouse-canvas"></canvas>

<div class="header">
  <h1>Love Game</h1>
  <p>~ A Quest to Assess your Mental, Physical, and Emotional Health ~</p>
</div>

<div class="navbar">
  <a href="index.html">Play</a>
  <a href="about.html">About</a>
  <a href="#">Community</a>
<!-- <a href="#" class="right">Log In</a> -->
</div>
  
<div id="intro-overlay">
  <canvas id="starfield"></canvas>
  <div id="intro-text" class="cyber-text">ENTERING CYBERSPACE <span id="loading-dots"></span></div>
</div>
<!-- SECOND SCREEN: REMINDERS -->
<div id="reminder-overlay" hidden>
  <div class="reminder-box">
    <h2>REMINDERS</h2>
    <ol class="reminder-list">
      <li>Be as truthful as possible (to ensure that your final result truly reflects your current health!)</li>
      <li>Play whenever you wish to reassess your wellbeing status . . .</li>
      <li>Should you land in a territory that concerns you, apply balanced Self and External love â€” and return later.</li>
      <li>Societal factors, including racial bias, socioeconomic barriers, and gender identity, may influence outcomes.</li>
      <li><strong>Ecstasy</strong> â€” The highest realm where energy and love abound.</li>
      <li><strong>Loveland</strong> â€” Balance exists, though some Murktivities linger.</li>
      <li><strong>Murkland</strong> â€” Clouded energy causes fluctuating health.</li>
      <li><strong>Darkland</strong> â€” A pit where murk compounds into darkness.</li>
    </ol>

    <button id="start-game">FOR SURE :)</button>
  </div>
</div>


<svg width="0" height="0" style="position: absolute;">
  <defs>
    <filter id="side-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.03 0.15" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
    <filter id="top-flames">
      <feTurbulence type="fractalNoise" baseFrequency="0.15 0.03" numOctaves="3">
        <animate attributeName="seed" from="1" to="100" dur="10s" repeatCount="indefinite" />
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" scale="40" />
    </filter>
  </defs>
</svg>
  
<script>
/* --- UNIVERSAL MOUSE STREAK SETUP --- */
const mCanvas = document.getElementById("mouse-canvas");
const mCtx = mCanvas.getContext("2d");
let mPoints = [];
const TRAIL_LIFESPAN = 12; // Shortened slightly to reduce lag

function resizeCanvases() {
  mCanvas.width = canvas.width = window.innerWidth;
  mCanvas.height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvases);

window.addEventListener("mousemove", (e) => {
  mPoints.push({ x: e.clientX, y: e.clientY, age: 0 });
});

/* --- INTRO STARFIELD SETUP --- */
const starColors = [[255, 255, 255], [200, 220, 255], [220, 200, 255], [255, 230, 180], [180, 255, 240]];
const overlay = document.getElementById("intro-overlay");
const canvas = document.getElementById("starfield");
const ctx = canvas.getContext("2d");

let stars = [];
let shootingStars = []; 
let fireEmbers = [];    
let running = true;

/* Initialize Stars */
function createStars(count = 120) { // Slightly fewer stars for better performance
  stars = [];
  for (let i = 0; i < count; i++) {
    const color = starColors[Math.floor(Math.random() * starColors.length)];
    stars.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      r: Math.random() * 1.4 + 0.3,
      speed: Math.random() * 0.12 + 0.05,
      color
    });
  }
}
createStars();

/* --- THE OPTIMIZED MERGED LOOP --- */
function animate() {
  // Clear both canvases
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  if (running) ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Draw Mouse Streak First (Optimization: Only one shadow call)
  if (mPoints.length > 1) {
    mCtx.shadowBlur = 8; // Lower value = faster performance
    mCtx.shadowColor = "#f5ff3a";
    mCtx.lineCap = "round";
    mCtx.lineJoin = "round";

    for (let i = 1; i < mPoints.length; i++) {
      const p1 = mPoints[i - 1];
      const p2 = mPoints[i];
      const opacity = 1 - (p1.age / TRAIL_LIFESPAN);
      
      mCtx.strokeStyle = `rgba(245, 255, 58, ${opacity})`; 
      mCtx.lineWidth = opacity * 5;
      
      mCtx.beginPath();
      mCtx.moveTo(p1.x, p1.y);
      mCtx.lineTo(p2.x, p2.y);
      mCtx.stroke();
      p1.age++;
    }
    mCtx.shadowBlur = 0; // Turn it off immediately for other elements
  }
  mPoints = mPoints.filter(p => p.age < TRAIL_LIFESPAN);

  // 2. Draw Intro Elements Only If Running
  if (running) {
    /* Background Stars */
    stars.forEach(star => {
      star.y += star.speed;
      if (star.y > canvas.height) star.y = 0;
      ctx.fillStyle = `rgba(${star.color[0]}, ${star.color[1]}, ${star.color[2]}, 0.8)`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    });

    /* Background Shooting Stars (White) */
    shootingStars.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) shootingStars.splice(i, 1);
    });

    /* Border Embers (Orange) */
    fireEmbers.forEach((s, i) => {
      s.x += s.vx; s.y += s.vy; s.life++;
      ctx.strokeStyle = "#ff8c00";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
      ctx.stroke();
      if (s.life > 25) fireEmbers.splice(i, 1);
    });

    /* Spawn Logic */
    if (Math.random() > 0.85) spawnEmbers();
  }

  requestAnimationFrame(animate);
}

function spawnEmbers() {
  const side = Math.floor(Math.random() * 4);
  let ex, ey, evx, evy;
  if (side === 0) { ex = Math.random()*canvas.width; ey = 0; evx = (Math.random()-0.5)*2; evy = Math.random()*4; } 
  else if (side === 1) { ex = Math.random()*canvas.width; ey = canvas.height; evx = (Math.random()-0.5)*2; evy = -Math.random()*4; } 
  else if (side === 2) { ex = 0; ey = Math.random()*canvas.height; evx = Math.random()*4; evy = (Math.random()-0.5)*2; } 
  else { ex = canvas.width; ey = Math.random()*canvas.height; evx = -Math.random()*4; evy = (Math.random()-0.5)*2; }
  fireEmbers.push({ x: ex, y: ey, vx: evx, vy: evy, life: 0 });
}

// Shooting star interval logic
function createShootingStar() {
  const c = starColors[Math.floor(Math.random() * starColors.length)];
  shootingStars.push({
    x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.5,
    vx: Math.random() * 7 + 5, vy: Math.random() * 3 + 2,
    life: 0, color: `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.7)`
  });
}
const shootingInterval = setInterval(() => { if (Math.random() > 0.4) createShootingStar(); }, 300);

/* End Intro Logic */
function endIntro() {
  running = false;
  clearInterval(shootingInterval);
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";
  setTimeout(() => overlay.remove(), 600);
}

const timeout = setTimeout(endIntro, 3500);
/* --- Improved Skip Logic --- */

// 1. Click to Skip
overlay.addEventListener("click", () => {
  clearTimeout(timeout);
  endIntro();
}, { once: true });

// 2. Keypress to Skip (Now targeting the whole window)
window.addEventListener("keydown", (e) => {
  // This ensures the intro ends regardless of which key is pressed
  clearTimeout(timeout);
  endIntro();
}, { once: true });

/* --- End Intro Logic (Ensure this matches) --- */
function endIntro() {
  if (!running && !overlay.parentNode) return; // Prevent running twice
  
  running = false;
  clearInterval(shootingInterval);
  
  // Smooth Fade Out
  overlay.style.transition = "opacity 0.8s ease, visibility 0.8s";
  overlay.style.opacity = "0";
  overlay.style.visibility = "hidden";
  
  // Completely remove from memory after fade
  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();
  }, 800);
}
resizeCanvases();
animate();
  
const dotsElement = document.getElementById('loading-dots');
let dotCount = 0;

const dotInterval = setInterval(() => {
  dotCount = (dotCount + 1) % 4; 
  // Adding a space after the dot inside the repeat function
  if(dotsElement) dotsElement.textContent = ". ".repeat(dotCount);
}, 400);

/* Update your endIntro function to stop the dots too */
function endIntro() {
  if (!running) return;
  running = false;

  clearInterval(shootingInterval);
  clearInterval(dotInterval);

  overlay.style.pointerEvents = "none";
  overlay.style.transition = "opacity 0.6s ease";
  overlay.style.opacity = "0";

  setTimeout(() => {
    if (overlay.parentNode) overlay.remove();

    // ðŸ”¥ SHOW SECOND SCREEN HERE
    enableReminderSkip();


  }, 600);
}
document.getElementById("start-game")?.addEventListener("click", () => {
  document.getElementById("reminder-overlay")?.remove();
});
function closeReminder() {
  const reminder = document.getElementById("reminder-overlay");
  if (!reminder) return;

  reminder.style.transition = "opacity 0.4s ease";
  reminder.style.opacity = "0";

  setTimeout(() => reminder.remove(), 400);

  window.removeEventListener("keydown", closeReminder);
  reminder.removeEventListener("click", closeReminder);
}

/* Enable skip */
function enableReminderSkip() {
  const reminder = document.getElementById("reminder-overlay");
  if (!reminder) return;

  reminder.style.opacity = "0";
  reminder.hidden = false;

  requestAnimationFrame(() => {
    reminder.style.transition = "opacity 0.4s ease";
    reminder.style.opacity = "1";
  });

  reminder.addEventListener("click", closeReminder);
  window.addEventListener("keydown", closeReminder);
}

</script>
</script>
</body>
</html>
